<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Arcade! Hooray! ‚Äî Minesweeper</title>
  <style>
    body, html {
      margin: 0; padding: 0; height: 100%;
      overflow: hidden;
      font-family: 'Segoe UI', system-ui, -apple-system, Arial, sans-serif;
      background: #111; color: #fff;
      touch-action: none;
    }
    :root{
      --ui-bg: rgba(255,255,255,0.07);
      --ui-bg2: rgba(0,0,0,0.32);
      --ui-border: rgba(255,255,255,0.16);
      --ui-border-strong: rgba(255,255,255,0.30);
      --ui-accent: #00e5ff;
      --ui-radius: 14px;
    }

    .ui-btn{
      display:inline-flex; align-items:center; justify-content:center;
      gap: 8px;
      padding: 9px 12px;
      border-radius: var(--ui-radius);
      border: 1px solid var(--ui-border);
      background: var(--ui-bg);
      color: #fff;
      font-weight: 900;
      letter-spacing: 0.2px;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
      cursor: pointer;
      backdrop-filter: blur(6px);
    }
    .ui-btn:active{ transform: scale(0.98); border-color: var(--ui-border-strong); }

    
    .back-btn{
      position: fixed;
      top: calc(env(safe-area-inset-top, 0px) + 10px);
      left: calc(env(safe-area-inset-left, 0px) + 10px);
      z-index: 1300;
      touch-action: none;
      cursor: grab;
    }
    .back-btn.dragging{ cursor: grabbing; }

    
    #app{
      position: absolute; inset: 0;
      display: flex;
      flex-direction: column;
      background: radial-gradient(circle at 30% 20%, #222 0%, #000 70%);
    }

    
    .topbar{
      flex: 0 0 auto;
      height: 64px;
      display: grid;
      grid-template-columns: 110px 1fr 110px;
      align-items: center;
      gap: 10px;
      padding: 0 12px;
      box-sizing: border-box;
      background: rgba(0,0,0,0.55);
      border-bottom: 1px solid rgba(255,255,255,0.14);
      padding-left: 90px; 
    }

    .counter{
      justify-self: start;
      width: 96px;
      height: 44px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(0,0,0,0.55);
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      font-weight: 900;
      font-size: 24px;
      letter-spacing: 2px;
      color: #ff3b3b;
      box-shadow: 0 10px 20px rgba(0,0,0,0.35);
      user-select:none;
    }

    .face{
      justify-self: center;
      width: 52px; height: 52px;
      border-radius: 50%;
      border: 1px solid rgba(255,255,255,0.22);
      background: rgba(255,255,255,0.08);
      display:flex; align-items:center; justify-content:center;
      font-size: 30px;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      cursor: pointer;
      box-shadow: 0 10px 20px rgba(0,0,0,0.35);
    }
    .face:active{ transform: translateY(1px) scale(0.99); }

    .timer{
      justify-self: end;
      width: 96px;
      height: 44px;
      display:flex; align-items:center; justify-content:center;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(0,0,0,0.55);
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      font-weight: 900;
      font-size: 24px;
      letter-spacing: 2px;
      color: #ffd700;
      box-shadow: 0 10px 20px rgba(0,0,0,0.35);
      user-select:none;
    }

    
    .board-wrap{
      flex: 1 1 auto;
      display:flex;
      align-items:center;
      justify-content:center;
      padding: 12px;
      box-sizing:border-box;
      position: relative;
      overflow: hidden;
    }

    .grid{
      display:grid;
      gap: 1px;
      background: rgba(255,255,255,0.20);
      padding: 4px;
      border-radius: 12px;
      box-shadow: 0 18px 44px rgba(0,0,0,0.55);
      touch-action: none;
    }

    .cell{
      width: var(--cell);
      height: var(--cell);
      border-radius: 8px;
      display:flex;
      align-items:center;
      justify-content:center;
      font-weight: 1000;
      line-height: 1;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      overflow: hidden;
      position: relative;

      border: 1px solid rgba(255,255,255,0.12);
      background: linear-gradient(135deg, #aaa, #888);
      box-shadow:
        inset 2px 2px 0 rgba(255,255,255,0.35),
        inset -2px -2px 0 rgba(0,0,0,0.22);
      cursor: pointer;
      font-size: clamp(14px, calc(var(--cell) * 0.48), 26px);
    }
    .cell.revealed{
      background: rgba(255,255,255,0.70);
      box-shadow: none;
      border-color: rgba(0,0,0,0.12);
      cursor: default;
    }
    .cell.mine.revealed{
      background: #ff4d4d;
      border-color: rgba(0,0,0,0.22);
    }
    .cell.flagged::after{
      content: "üö©";
      position:absolute;
      font-size: clamp(16px, calc(var(--cell) * 0.55), 28px);
      filter: drop-shadow(0 2px 2px rgba(0,0,0,0.35));
    }

    
    .n1{ color:#0b55ff; }
    .n2{ color:#148a2e; }
    .n3{ color:#d11f1f; }
    .n4{ color:#0b1a74; }
    .n5{ color:#7a0b0b; }
    .n6{ color:#0b7a7a; }
    .n7{ color:#111; }
    .n8{ color:#555; }

    
    .overlay{
      position: absolute; inset: 0;
      background: rgba(0,0,0,0.86);
      backdrop-filter: blur(6px);
      display:none;
      align-items:center;
      justify-content:center;
      z-index: 1200;
      padding: 18px;
      box-sizing: border-box;
    }
    .overlay.show{ display:flex; }

    .panel{
      width: min(560px, calc(100vw - 28px));
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,0.22);
      background: rgba(20,20,20,0.92);
      box-shadow: 0 18px 48px rgba(0,0,0,0.55);
      padding: 16px;
      text-align:center;
    }
    .panel h1{
      margin: 6px 0 4px;
      font-size: clamp(28px, 6vw, 44px);
      letter-spacing: 2px;
      color: #ffd700;
      text-shadow: 0 0 12px rgba(255,215,0,0.22);
      font-weight: 1000;
    }
    .panel .sub{
      margin: 0 0 14px;
      color: rgba(255,255,255,0.76);
      font-weight: 700;
      line-height: 1.25;
    }
    .choices{
      display:grid;
      grid-template-columns: 1fr;
      gap: 10px;
      margin-top: 10px;
    }
    .big-btn{
      width: 100%;
      padding: 16px 14px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.08);
      color:#fff;
      font-weight: 1000;
      letter-spacing: 0.6px;
      font-size: 18px;
      cursor:pointer;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
    }
    .big-btn:active{ transform: scale(0.99); border-color: rgba(255,255,255,0.32); }
    .big-btn .mini{
      display:block;
      font-size: 12px;
      color: rgba(255,255,255,0.70);
      font-weight: 800;
      letter-spacing: 0.4px;
      margin-top: 4px;
    }
    .row{
      display:flex;
      gap: 10px;
      margin-top: 12px;
      flex-wrap: wrap;
      justify-content: center;
    }
    .small{
      padding: 10px 12px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(0,0,0,0.25);
      color: rgba(255,255,255,0.88);
      font-weight: 900;
      cursor:pointer;
    }

    
    #feedback-overlay{
      display:none;
      position:absolute;
      inset: 0;
      z-index: 2000;
      align-items:center;
      justify-content:center;
      background: rgba(0,0,0,0.70);
      pointer-events:none;
    }
    #feedback-content{
      font-size: 15vw;
      font-weight: 1000;
      text-shadow: 0 0 30px rgba(255,255,255,0.8);
      animation: popIn 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
      width:100%;
      text-align:center;
      letter-spacing: 2px;
    }
    .fb-win{ color:#2ecc71; }
    .fb-loss{ color:#e74c3c; animation: shake 0.5s ease-in-out !important; }
    @keyframes popIn { 0% { transform: scale(0); opacity: 0; } 80% { transform: scale(1.2); opacity: 1; } 100% { transform: scale(1); opacity: 1; } }
    @keyframes shake { 0%, 100% {transform: translateX(0);} 25% {transform: translateX(-16px) rotate(-3deg);} 75% {transform: translateX(16px) rotate(3deg);} }

    @media (max-height: 620px){
      .topbar{ height: 58px; }
      .counter, .timer{ height: 40px; font-size: 22px; }
      .face{ width: 48px; height: 48px; font-size: 28px; }
    }
  

        .splash-title{ color:#ffd700 !important; text-shadow:0 0 16px rgba(255,215,0,0.25) !important; }
        [id$="-menu"].overlay, #menuOverlay, #startOverlay, #cat-menu, #g-balloons .b-start-overlay{ background: rgba(0,0,0,0.95) !important; }
        #cat-menu .menu-title, #startOverlay .panel h1, #g-balloons .b-start-overlay h1{ color:#ffd700 !important; text-shadow:0 0 18px rgba(255,215,0,0.35) !important; }
        #startOverlay .big-btn, #startOverlay .small, #cat-menu .cat-btn, #g-balloons .b-start-overlay .btn-large-opt{ background:#333 !important; border:2px solid #555 !important; border-radius:15px !important; color:#fff !important; font-weight:900 !important; box-shadow:none !important; }
        #g-balloons .b-start-overlay .btn-large-opt{ font-size: 1.9rem !important; padding: 20px 28px !important; max-width: 320px; width: 80%; }
    </style>
</head>
<body>
  <button class="ui-btn back-btn" id="menuBtn">‚Üê MENU</button>

  <div id="app">
    <div class="topbar">
      <div class="counter" id="mineCounter">010</div>
      <div class="face" id="faceBtn" title="New game">üôÇ</div>
      <div class="timer" id="timeCounter">000</div>
    </div>

    <div class="board-wrap">
      <div class="grid" id="grid"></div>

      
      <div class="overlay show" id="startOverlay">
        <div class="panel">
          <h1>MINESWEEPER</h1>
          <div class="sub">
            Tap to reveal. <b>Long-press</b> to place a flag.<br/>
            Pick a board:
          </div>

          <div class="choices">
            <button class="big-btn" data-diff="easy">
              EASY
              <span class="mini">9 √ó 9 ‚Ä¢ 10 mines</span>
            </button>
            <button class="big-btn" data-diff="medium">
              MEDIUM
              <span class="mini">12 √ó 12 ‚Ä¢ 20 mines</span>
            </button>
            <button class="big-btn" data-diff="hard">
              HARD
              <span class="mini">16 √ó 16 ‚Ä¢ 40 mines</span>
            </button>
          </div>

          <div class="row">
            <button class="small" id="howBtn">How to play</button>
            <button class="small" id="resumeBtn" style="display:none;">Resume</button>
          </div>

          <div class="sub" id="howText" style="display:none; margin-top:12px;">
            Reveal all safe squares to win. If you reveal a mine ‚Äî boom.
            The mine counter shows <b>mines minus flags</b>. On a win, any remaining mines auto-flag.
          </div>
        </div>
      </div>

      
      <div id="feedback-overlay">
        <div id="feedback-content" class="fb-win">AWESOME!</div>
        <canvas id="feedback-confetti" style="position:absolute; inset:0; width:100%; height:100%; pointer-events:none;"></canvas>
      </div>
    </div>
  </div>

  <script>
    
    function goToMenu(){
      window.location.href = 'index.html';
    }
    document.getElementById('menuBtn').addEventListener('click', goToMenu);

    
    (function(){
      const el = document.getElementById('menuBtn');
      if(!el) return;

      const storeKey = 'arcade_btnpos_menu_mines';
      const clamp = (v,min,max)=> Math.max(min, Math.min(max, v));
      let dragging = false, moved = false;
      let sx=0, sy=0, startL=0, startT=0;

      
      try{
        const raw = localStorage.getItem(storeKey);
        if(raw){
          const p = JSON.parse(raw);
          if(p && Number.isFinite(p.left) && Number.isFinite(p.top)){
            el.style.left = p.left + 'px';
            el.style.top  = p.top  + 'px';
            el.style.right = 'auto';
            el.style.bottom = 'auto';
          }
        }
      }catch(e){}

      el.addEventListener('pointerdown', (e)=>{
        if(e.button != null && e.button !== 0) return;
        dragging = true; moved = false;
        el.setPointerCapture?.(e.pointerId);
        const r = el.getBoundingClientRect();
        sx = e.clientX; sy = e.clientY;
        startL = r.left; startT = r.top;
        el.classList.add('dragging');
      });

      window.addEventListener('pointermove', (e)=>{
        if(!dragging) return;
        const dx = e.clientX - sx;
        const dy = e.clientY - sy;
        if(!moved && (Math.abs(dx)+Math.abs(dy)) > 8) moved = true;
        if(!moved) return;

        e.preventDefault();
        const w = el.offsetWidth, h = el.offsetHeight;
        const maxL = window.innerWidth  - w - 6;
        const maxT = window.innerHeight - h - 6;
        const L = clamp(startL + dx, 6, maxL);
        const T = clamp(startT + dy, 6, maxT);
        el.style.left = L + 'px';
        el.style.top  = T + 'px';
        el.style.right = 'auto';
        el.style.bottom = 'auto';
      }, {passive:false});

      window.addEventListener('pointerup', ()=>{
        if(!dragging) return;
        dragging = false;
        el.classList.remove('dragging');
        if(moved){
          try{
            const r = el.getBoundingClientRect();
            localStorage.setItem(storeKey, JSON.stringify({left: r.left, top: r.top}));
          }catch(e){}
          
          const swallow = (ev)=>{ ev.preventDefault(); ev.stopPropagation(); };
          el.addEventListener('click', swallow, {once:true, capture:true});
        }
      });
    })();

    
    const Feedback = (function(){
      const overlay = document.getElementById('feedback-overlay');
      const text = document.getElementById('feedback-content');
      const canvas = document.getElementById('feedback-confetti');
      const ctx = canvas.getContext('2d');
      let particles = [];
      let animId = null;
      let tHandle = null;

      function resize(){
        canvas.width  = overlay.clientWidth;
        canvas.height = overlay.clientHeight;
      }

      function spawnConfetti(){
        particles = [];
        const colors = ['#f00','#0f0','#00f','#ff0','#0ff','#f0f','#ffd700','#00e5ff'];
        for(let i=0;i<110;i++){
          particles.push({
            x: canvas.width/2,
            y: canvas.height/2,
            vx: (Math.random()-0.5)*22,
            vy: (Math.random()-0.7)*22,
            g: 0.55 + Math.random()*0.25,
            s: 4 + Math.random()*8,
            c: colors[(Math.random()*colors.length)|0],
            r: Math.random()*Math.PI*2,
            vr: (Math.random()-0.5)*0.25
          });
        }
      }

      function loop(){
        ctx.clearRect(0,0,canvas.width,canvas.height);
        for(const p of particles){
          p.vy += p.g;
          p.x  += p.vx;
          p.y  += p.vy;
          p.r  += p.vr;
          ctx.save();
          ctx.translate(p.x, p.y);
          ctx.rotate(p.r);
          ctx.fillStyle = p.c;
          ctx.fillRect(-p.s/2, -p.s/2, p.s, p.s);
          ctx.restore();
        }
        animId = requestAnimationFrame(loop);
      }

      function show(win){
        if(tHandle){ clearTimeout(tHandle); tHandle = null; }
        if(animId){ cancelAnimationFrame(animId); animId = null; }
        overlay.style.display = 'flex';

        text.className = win ? 'fb-win' : 'fb-loss';
        text.textContent = win ? 'AWESOME!' : 'BOOM!';
        resize();

        if(win){
          spawnConfetti();
          loop();
        }else{
          ctx.clearRect(0,0,canvas.width,canvas.height);
        }

        tHandle = setTimeout(()=>{
          overlay.style.display = 'none';
          if(animId){ cancelAnimationFrame(animId); animId = null; }
          tHandle = null;
        }, 1200);
      }

      window.addEventListener('resize', ()=>{ if(overlay.style.display==='flex') resize(); });
      return { show };
    })();

    
    const gridEl = document.getElementById('grid');
    const mineCounterEl = document.getElementById('mineCounter');
    const timeCounterEl = document.getElementById('timeCounter');
    const faceBtn = document.getElementById('faceBtn');

    const startOverlay = document.getElementById('startOverlay');
    const howBtn = document.getElementById('howBtn');
    const howText = document.getElementById('howText');
    const resumeBtn = document.getElementById('resumeBtn');

    const DIFFS = {
      easy:   { rows: 9,  cols: 9,  mines: 10 },
      medium: { rows: 12, cols: 12, mines: 20 },
      hard:   { rows: 16, cols: 16, mines: 40 }
    };

    let rows=9, cols=9, mines=10;
    let cellPx = 28;
    let grid = [];
    let gameOver = false;
    let won = false;
    let started = false;
    let minesPlaced = false;

    let startTime = 0;
    let timerId = null;

    function pad3(n){
      n = Math.max(0, Math.min(999, n|0));
      return String(n).padStart(3,'0');
    }

    function setFace(state){
      
      if(state === 'win') faceBtn.textContent = 'üòé';
      else if(state === 'dead') faceBtn.textContent = 'üòµ';
      else if(state === 'oops') faceBtn.textContent = 'üòÆ';
      else faceBtn.textContent = 'üôÇ';
    }

    function stopTimer(){
      if(timerId){ clearInterval(timerId); timerId = null; }
    }
    function startTimer(){
      stopTimer();
      startTime = Date.now();
      timeCounterEl.textContent = '000';
      timerId = setInterval(()=>{
        const t = Math.floor((Date.now() - startTime)/1000);
        timeCounterEl.textContent = pad3(t);
      }, 250);
    }

    function showOverlay(show, allowResume=false){
      startOverlay.classList.toggle('show', !!show);
      resumeBtn.style.display = (show && allowResume) ? 'inline-flex' : 'none';
    }

    howBtn.addEventListener('click', ()=>{
      howText.style.display = (howText.style.display === 'none') ? 'block' : 'none';
    });
    resumeBtn.addEventListener('click', ()=>{
      showOverlay(false);
    });

    
    startOverlay.addEventListener('click', (e)=>{
      const btn = e.target.closest('.big-btn');
      if(!btn) return;
      const diff = btn.getAttribute('data-diff');
      newGame(diff);
      showOverlay(false);
    });

    faceBtn.addEventListener('click', ()=>{
      
      showOverlay(true, started && !gameOver);
    });

    function newGame(diffKey){
      const d = DIFFS[diffKey] || DIFFS.easy;
      rows = d.rows; cols = d.cols; mines = d.mines;

      
      const vw = window.innerWidth;
      const vh = window.innerHeight;
      const usableW = vw - 24;
      const usableH = vh - 64 - 24 - 8; 
      const pxW = Math.floor((usableW - 10) / cols);
      const pxH = Math.floor((usableH - 10) / rows);
      cellPx = Math.max(18, Math.min(34, Math.min(pxW, pxH)));
      gridEl.style.setProperty('--cell', cellPx + 'px');
      gridEl.style.gridTemplateColumns = `repeat(${cols}, var(--cell))`;
      gridEl.style.gridTemplateRows = `repeat(${rows}, var(--cell))`;

      gameOver = false;
      won = false;
      started = false;
      minesPlaced = false;

      stopTimer();
      timeCounterEl.textContent = '000';
      setFace('ready');

      buildEmptyGrid();
      renderAll();

      
      mineCounterEl.textContent = pad3(mines); 
    }

    function buildEmptyGrid(){
      grid = [];
      gridEl.innerHTML = '';

      for(let r=0;r<rows;r++){
        const row = [];
        for(let c=0;c<cols;c++){
          const el = document.createElement('div');
          el.className = 'cell';
          el.setAttribute('role','button');
          el.setAttribute('aria-label','cell');
          gridEl.appendChild(el);

          const cell = {
            r, c, el,
            mine: false,
            revealed: false,
            flagged: false,
            adj: 0,
            _lastFlagAt: 0
          };
          row.push(cell);

          attachCellHandlers(cell);
        }
        grid.push(row);
      }
    }

    function neighbors(r,c){
      const out = [];
      for(let dr=-1; dr<=1; dr++){
        for(let dc=-1; dc<=1; dc++){
          if(!dr && !dc) continue;
          const rr = r+dr, cc = c+dc;
          if(rr>=0 && rr<rows && cc>=0 && cc<cols) out.push(grid[rr][cc]);
        }
      }
      return out;
    }
    function chordReveal(r,c){
      const cell = grid[r][c];
      if(gameOver) return;
      if(!cell.revealed) return;
      if(cell.mine) return;
      if(cell.adj <= 0) return;

      const neigh = neighbors(r,c);
      let flagged = 0;
      for(const n of neigh) if(n.flagged) flagged++;

      if(flagged !== cell.adj) return;

      for(const n of neigh){
        if(gameOver) return;
        if(n.flagged || n.revealed) continue;
        reveal(n.r, n.c);
      }
    }


    function placeMinesAvoiding(firstR, firstC){
      
      const forbidden = new Set();
      forbidden.add(firstR + ',' + firstC);
      for(const n of neighbors(firstR, firstC)){
        forbidden.add(n.r + ',' + n.c);
      }

      
      const candidates = [];
      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          if(!forbidden.has(r+','+c)) candidates.push(grid[r][c]);
        }
      }

      
      for(let i=candidates.length-1;i>0;i--){
        const j = (Math.random()*(i+1))|0;
        [candidates[i], candidates[j]] = [candidates[j], candidates[i]];
      }

      
      for(let r=0;r<rows;r++) for(let c=0;c<cols;c++){
        grid[r][c].mine = false;
        grid[r][c].adj = 0;
      }

      
      for(let i=0;i<mines;i++){
        candidates[i].mine = true;
      }

      
      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          const cell = grid[r][c];
          if(cell.mine) continue;
          let count = 0;
          for(const n of neighbors(r,c)) if(n.mine) count++;
          cell.adj = count;
        }
      }

      minesPlaced = true;
    }

    function countFlags(){
      let f=0;
      for(let r=0;r<rows;r++) for(let c=0;c<cols;c++) if(grid[r][c].flagged) f++;
      return f;
    }

    function updateMineCounter(){
      const flags = countFlags();
      const left = mines - flags;
      mineCounterEl.textContent = pad3(left);
    }

    function reveal(r,c){
      const cell = grid[r][c];
      if(gameOver) return;
      if(cell.revealed) return;
      if(cell.flagged) return;

      
      if(!started){
        started = true;
        startTimer();
      }
      if(!minesPlaced){
        placeMinesAvoiding(r,c);
      }

      cell.revealed = true;

      if(cell.mine){
        
        gameOver = true;
        won = false;
        stopTimer();
        setFace('dead');
        revealAllMines(cell);
        renderAll();
        Feedback.show(false);
        
        setTimeout(()=> showOverlay(true, false), 650);
        return;
      }

      
      if(cell.adj === 0){
        const stack = [cell];
        while(stack.length){
          const cur = stack.pop();
          for(const n of neighbors(cur.r, cur.c)){
            if(n.revealed || n.flagged) continue;
            if(n.mine) continue;
            n.revealed = true;
            if(n.adj === 0) stack.push(n);
          }
        }
      }

      renderAll();
      checkWin();
    }

    function revealAllMines(triggerCell){
      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          const cell = grid[r][c];
          if(cell.mine){
            cell.revealed = true;
          }
        }
      }
      
      if(triggerCell){
        triggerCell.el.style.outline = '3px solid rgba(255,255,255,0.8)';
        triggerCell.el.style.outlineOffset = '-2px';
      }
    }

    function autoFlagRemainingMines(){
      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          const cell = grid[r][c];
          if(cell.mine && !cell.flagged){
            cell.flagged = true;
          }
        }
      }
      updateMineCounter(); 
    }

    function checkWin(){
      if(gameOver) return;

      
      let revealedSafe = 0;
      const totalSafe = rows*cols - mines;

      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          const cell = grid[r][c];
          if(!cell.mine && cell.revealed) revealedSafe++;
        }
      }

      if(revealedSafe >= totalSafe){
        gameOver = true;
        won = true;
        stopTimer();
        setFace('win');

        
        autoFlagRemainingMines();
        renderAll();
        mineCounterEl.textContent = '000';

        Feedback.show(true);
        setTimeout(()=> showOverlay(true, false), 650);
      }
    }

    function toggleFlag(r,c){
      const cell = grid[r][c];
      if(gameOver) return;
      if(cell.revealed) return;

      
      const now = performance.now();
      if(now - (cell._lastFlagAt || 0) < 320) return;
      cell._lastFlagAt = now;

      cell.flagged = !cell.flagged;
      updateMineCounter();
      renderCell(cell);
      
      checkWinByFlags();
    }

    function checkWinByFlags(){
      if(gameOver) return;
      const flags = countFlags();
      if(flags !== mines) return;

      
      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          const cell = grid[r][c];
          if(cell.mine && !cell.flagged) return;
          if(!cell.mine && cell.flagged) return;
        }
      }

      gameOver = true;
      won = true;
      stopTimer();
      setFace('win');
      mineCounterEl.textContent = '000';
      renderAll();
      Feedback.show(true);
      setTimeout(()=> showOverlay(true, false), 650);
    }

    function renderCell(cell){
      const el = cell.el;

      
      el.className = 'cell';
      if(cell.revealed) el.classList.add('revealed');
      if(cell.revealed && cell.mine) el.classList.add('mine');
      if(cell.flagged && !cell.revealed) el.classList.add('flagged');

      
      el.textContent = '';

      if(cell.revealed){
        if(cell.mine){
          el.textContent = 'üí£';
          return;
        }
        if(cell.adj > 0){
          el.textContent = String(cell.adj);
          el.classList.add('n'+cell.adj);
        }
      }
    }

    function renderAll(){
      for(let r=0;r<rows;r++) for(let c=0;c<cols;c++) renderCell(grid[r][c]);
      updateMineCounter();
    }

    
    function attachCellHandlers(cell){
      let pressTimer = null;
      let isLong = false;
      let sx=0, sy=0;

      const CANCEL_DIST2 = 14*14;
      const LONG_MS = 460;

      function clearTimer(){
        if(pressTimer){ clearTimeout(pressTimer); pressTimer = null; }
      }

      cell.el.addEventListener('contextmenu', (e)=>{ e.preventDefault(); }, {passive:false});

      cell.el.addEventListener('pointerdown', (e)=>{
        if(gameOver) return;
        e.preventDefault();

        
        try{ cell.el.setPointerCapture(e.pointerId); }catch(_){}

        isLong = false;
        sx = e.clientX; sy = e.clientY;

        clearTimer();
        pressTimer = setTimeout(()=>{
          isLong = true;
          toggleFlag(cell.r, cell.c);
        }, LONG_MS);

        setFace('oops'); 
      }, {passive:false});

      cell.el.addEventListener('pointermove', (e)=>{
        if(!pressTimer) return;
        const dx = e.clientX - sx;
        const dy = e.clientY - sy;
        if((dx*dx + dy*dy) > CANCEL_DIST2){
          clearTimer();
        }
      }, {passive:true});

      cell.el.addEventListener('pointerup', (e)=>{
        setFace(gameOver ? (won?'win':'dead') : 'ready');
        if(pressTimer){ clearTimer(); }
        if(gameOver) return;
        if(!isLong){
          if(cell.revealed){
            chordReveal(cell.r, cell.c);
          }else{
            reveal(cell.r, cell.c);
          }
        }
      });

      cell.el.addEventListener('pointercancel', ()=>{
        setFace(gameOver ? (won?'win':'dead') : 'ready');
        clearTimer();
      });
    }

    
    window.addEventListener('load', ()=>{
      
      newGame('easy');
      showOverlay(true, false);
    });

    window.addEventListener('resize', ()=>{
      
      const cur = Object.entries(DIFFS).find(([,d])=>d.rows===rows && d.cols===cols && d.mines===mines)?.[0] || 'easy';
      const overlayShowing = startOverlay.classList.contains('show');
      newGame(cur);
      if(overlayShowing) showOverlay(true, started && !gameOver);
    });
  </script>
</body>
</html>
