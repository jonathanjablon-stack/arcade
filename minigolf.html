<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Arcade! Hooray!</title>
    <style>
        
        body, html { margin: 0; padding: 0; height: 100%; overflow: hidden; font-family: 'Segoe UI', system-ui, sans-serif; background: #111; color: white; touch-action: none; }
        :root{
            --ui-bg: rgba(255,255,255,0.07);
            --ui-bg2: rgba(0,0,0,0.32);
            --ui-border: rgba(255,255,255,0.16);
            --ui-border-strong: rgba(255,255,255,0.28);
            --ui-accent: #00e5ff;
            --ui-radius: 14px;
        }
        .ui-btn{
            display:inline-flex; align-items:center; justify-content:center;
            gap: 8px;
            padding: 8px 12px;
            border-radius: var(--ui-radius);
            border: 1px solid var(--ui-border);
            background: var(--ui-bg);
            color: #fff;
            font-weight: 800;
            letter-spacing: 0.2px;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        .ui-btn:active{ transform: scale(0.98); border-color: var(--ui-border-strong); }

        
        #main-menu {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            background: linear-gradient(135deg, #1a1a1a, #000); z-index: 999;
            transition: opacity 0.3s;
        }
        
        .menu-title { font-size: 2.2rem; margin-bottom: 16px; color: #ffd700; text-shadow: 0 0 12px rgba(255,215,0,0.25); font-weight: 900; letter-spacing: 2px; text-align: center; line-height: 1; }
        
        .menu-grid { 
            display: grid; 
            grid-template-columns: repeat(4, 1fr); 
            gap: 12px; 
            padding: 12px; 
            max-width: 920px;
            width: 100%;
            box-sizing: border-box;
        }
        
        .game-card {
            width: 100%; height: 86px;
            background: #333; border: 2px solid #555; border-radius: 14px;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            cursor: pointer; transition: all 0.2s; box-shadow: 0 5px 15px rgba(0,0,0,0.35);
        }
        .game-card:hover { transform: translateY(-5px); border-color: #fff; background: #444; }
        .game-card h2 { margin: 0; font-size: 1.2rem; pointer-events: none; }
        .game-card span { font-size: 0.72rem; color: #aaa; margin-top: 3px; pointer-events: none; text-align:center; }

        .game-view {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: none; z-index: 100;
        }
        .game-view.active { display: flex; }

        .back-btn{position:fixed;top:calc(env(safe-area-inset-top, 0px) + 10px);left:calc(env(safe-area-inset-left, 0px) + 10px);z-index:1000;background:rgba(0,0,0,0.55);color:#fff;border:1px solid var(--ui-border);padding:9px 12px;border-radius:var(--ui-radius);cursor:pointer;font-size:14px;backdrop-filter:blur(6px);font-weight:900;letter-spacing:0.2px;}
        .back-btn:hover{background:rgba(255,255,255,0.10);border-color:var(--ui-border-strong);}

        
        
        
        #global-settings-btn{
            position: fixed;
            top: calc(env(safe-area-inset-top, 0px) + 10px);
            right: calc(env(safe-area-inset-right, 0px) + 10px);
            z-index: 1300;
            padding: 8px 10px;
            min-width: 44px;
        }
        body.swap-corners #global-settings-btn{ right: auto; left: 10px; }
        body.swap-corners .back-btn{ left: auto !important; right: 10px !important; }

        #global-settings-modal{
            position: fixed; inset: 0;
            display: none;
            align-items: center;
            justify-content: center;
            background: rgba(0,0,0,0.65);
            backdrop-filter: blur(6px);
            z-index: 2000;
        }
        #global-settings-modal .settings-panel{
            width: min(520px, calc(100vw - 28px));
            background: rgba(20,20,20,0.92);
            border: 1px solid var(--ui-border-strong);
            border-radius: 18px;
            box-shadow: 0 18px 48px rgba(0,0,0,0.55);
            padding: 14px 14px 12px 14px;
        }
        #global-settings-modal .settings-head{
            display:flex; align-items:center; justify-content:space-between;
            gap: 12px;
            margin-bottom: 10px;
        }
        #global-settings-modal .settings-title{
            font-weight: 900;
            letter-spacing: 0.6px;
            font-size: 1.15rem;
            color: #ffd700;
            text-shadow: 0 0 12px rgba(255,215,0,0.18);
        }
        #global-settings-modal .settings-close{
            padding: 6px 10px;
            min-width: 44px;
        }
        #global-settings-modal .settings-row{
            display:flex;
            align-items:center;
            justify-content:space-between;
            gap: 12px;
            padding: 10px 10px;
            border-radius: 14px;
            border: 1px solid rgba(255,255,255,0.10);
            background: rgba(255,255,255,0.05);
            margin: 8px 0;
        }
        #global-settings-modal .settings-row .label{
            display:flex; flex-direction:column; gap: 3px;
        }
        #global-settings-modal .settings-row .label .name{
            font-weight: 900;
        }
        #global-settings-modal .settings-row .label .desc{
            font-size: 12px;
            color: rgba(255,255,255,0.72);
        }
        #global-settings-modal input[type="checkbox"]{
            width: 20px; height: 20px;
            accent-color: var(--ui-accent);
        }
        #global-settings-modal .settings-actions{
            display:flex; gap: 10px; justify-content:flex-end; align-items:center;
            margin-top: 10px;
        }

        
        body.reduce-motion *, body.reduce-motion *::before, body.reduce-motion *::after{
            animation: none !important;
            transition: none !important;
        }
        body.high-contrast{
            background: #000;
            --ui-bg: rgba(255,255,255,0.14);
            --ui-bg2: rgba(0,0,0,0.62);
            --ui-border: rgba(255,255,255,0.34);
            --ui-border-strong: rgba(255,255,255,0.62);
        }
        body.high-contrast .game-card{
            background: #111;
            border-color: rgba(255,255,255,0.75);
        }
        body.high-contrast .game-card:hover{
            background: #1a1a1a;
            border-color: #fff;
        }
.overlay {
            position: absolute; top:0; left:0; right:0; bottom:0;
            background: rgba(0,0,0,0.95); z-index: 50;
            display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 20px;
        }
        .splash-title { font-size: 3rem; color: #fff; margin-bottom: 20px; text-shadow: 0 0 10px rgba(255,255,255,0.3); text-align: center; }
        .btn-large-opt {
            background: #333; border: 2px solid #555; color: #fff;
            padding: 20px; font-size: 1.5rem; border-radius: 15px; width: 80%; max-width: 300px;
            cursor: pointer; transition: transform 0.1s; text-align: center;
        }
        .btn-large-opt:active { transform: scale(0.98); background: #444; }

        
        #feedback-overlay {
            display: none; position: absolute; top:0; left:0; width:100%; height:100%;
            z-index: 2000; align-items: center; justify-content: center;
            background: rgba(0,0,0,0.7); pointer-events: none;
        }
        #feedback-content { font-size: 15vw; font-weight: 900; text-shadow: 0 0 30px rgba(255,255,255,0.8); animation: popIn 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275); width:100%; text-align: center; }
        .fb-win { color: #2ecc71; }
        .fb-loss { color: #e74c3c; animation: shake 0.5s ease-in-out !important; }
        @keyframes popIn { 0% { transform: scale(0); opacity: 0; } 80% { transform: scale(1.2); opacity: 1; } 100% { transform: scale(1); opacity: 1; } }
        @keyframes shake { 0%, 100% {transform: translateX(0);} 25% {transform: translateX(-20px) rotate(-5deg);} 75% {transform: translateX(20px) rotate(5deg);} }

        
        .keypad { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin-top: 10px; max-width: 250px; }
        .kp-btn { 
            background: #444; border: 1px solid #666; color: #fff; 
            padding: 15px; font-size: 20px; border-radius: 8px; cursor: pointer; user-select: none;
        }
        .kp-btn:active { background: #666; }
        .kp-act { background: #2980b9; border-color: #3498db; }
        .kp-del { background: #c0392b; border-color: #e74c3c; }
        .kp-ok { background: #27ae60; border-color: #2ecc71; grid-column: span 3; }

        
        #g-blackjack {
            --felt-color: #277714; --felt-dark: #1b520e;
            --card-w: 75px; --card-h: 108px; --chip-size: 55px;
            background-color: #111; flex-direction: column;
        }
        #g-blackjack .modal-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); z-index: 100;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            gap: 20px; text-align: center;
        }
        #g-blackjack .btn-large {
            padding: 20px 30px; font-size: 20px; background: linear-gradient(145deg, #d4af37, #b49020);
            border: 2px solid #fff; border-radius: 12px; cursor: pointer; font-weight: bold; color: #111; min-width: 140px;
        }
        #g-blackjack #table {
            flex: 1; background: radial-gradient(circle at center, var(--felt-color) 0%, var(--felt-dark) 90%);
            display: flex; flex-direction: column; position: relative; width: 100%;
        }
        #g-blackjack #status-banner {
            background: rgba(0,0,0,0.7); color: #d4af37; text-align: center; padding: 10px;
            font-size: 18px; font-weight: bold; border-bottom: 1px solid #d4af37;
            text-transform: uppercase; letter-spacing: 1px; padding-left: 90px;
            display: flex; justify-content: center; align-items: center; gap: 20px; min-height: 44px;
        }
        #g-blackjack #dealer-area {
            flex: 0 0 180px; display: flex; flex-direction: column; align-items: center; justify-content: center;
            border-bottom: 1px solid rgba(255,255,255,0.1); padding-top: 10px;
        }
        #g-blackjack .dealer-rule-text { font-size: 10px; color: rgba(255,255,255,0.4); text-transform: uppercase; margin-top: 2px; }
        #g-blackjack #players-area {
            flex: 1; display: flex; justify-content: center; align-items: flex-start;
            gap: 5px; padding: 10px; overflow-x: auto; width: 100%; box-sizing: border-box;
        }
        #g-blackjack .player-seat {
            display: flex; flex-direction: column; align-items: center;
            min-width: 95px; flex: 1; max-width: 200px;
            opacity: 1; transition: opacity 0.3s; position: relative;
        }
        #g-blackjack .player-seat.inactive { opacity: 0.5; }
        #g-blackjack .player-seat.bankrupt { opacity: 0.3; filter: grayscale(100%); }
        #g-blackjack .player-info {
            background: rgba(0,0,0,0.7); padding: 4px; border-radius: 6px;
            text-align: center; width: 90%; margin-bottom: 5px; border: 1px solid #555; z-index: 20;
            display: flex; flex-direction: column; gap: 2px;
        }
        #g-blackjack .player-seat.active .player-info { border-color: #d4af37; box-shadow: 0 0 10px #d4af37; }
        #g-blackjack .p-name { font-size: 12px; font-weight: bold; color: #aaa; }
        #g-blackjack .p-bank { font-size: 13px; color: #4f4; font-family: monospace; }
        #g-blackjack .p-bet { font-size: 14px; color: #ffd700; font-family: monospace; font-weight: bold; border-top: 1px solid #444; margin-top: 2px; padding-top: 2px; }
        
        #g-blackjack .visual-chips {
            height: 40px; width: 100%; display: flex; flex-direction: column-reverse; 
            align-items: center; position: relative; top: -10px;
        }
        #g-blackjack .v-chip {
            width: 40px; height: 10px; border-radius: 50%; border: 2px dashed rgba(255,255,255,0.5);
            margin-top: -6px; box-shadow: 0 2px 4px #000;
        }
        
        #g-blackjack .hands-wrapper { display: flex; justify-content: center; width: 100%; gap: 10px; }
        #g-blackjack .hand-container { position: relative; height: 200px; width: 90px; margin-top: 10px; transition: opacity 0.3s; }
        #g-blackjack .card {
            width: var(--card-w); height: var(--card-h);
            background: #fff; border-radius: 6px; position: absolute;
            box-shadow: -2px 2px 5px rgba(0,0,0,0.5);
            display: flex; flex-direction: column; justify-content: space-between;
            padding: 4px; box-sizing: border-box; font-weight: bold; font-size: 18px;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275); top: 0; left: 0;
        }
        #g-blackjack .card.red { color: #d00; } 
        #g-blackjack .card.black { color: #000; }
        #g-blackjack .rank-suit { line-height: 0.9; display: flex; flex-direction: column; align-items: center; }
        #g-blackjack .big-suit { position: absolute; top:50%; left:50%; transform: translate(-50%,-50%); font-size: 36px; opacity: 0.2; }
        #g-blackjack .bottom-right { transform: rotate(180deg); position: absolute; bottom: 4px; right: 4px; }
        #g-blackjack .card-back { background: repeating-linear-gradient(45deg, #900, #900 5px, #a00 5px, #a00 10px); border: 2px solid #fff; }
        #g-blackjack .card-back * { display: none; }
        #g-blackjack .bubble {
            border-radius: 20px; position: absolute; z-index: 50;
            box-shadow: 0 3px 6px rgba(0,0,0,0.8); font-weight: bold;
            display: flex; justify-content: center; align-items: center;
        }
        #g-blackjack .score-bubble { 
            top: -15px; right: -10px; background: #d4af37; color: #000;
            font-size: 18px; min-width: 32px; height: 32px; border: 2px solid #fff;
        }
        #g-blackjack .result-text {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-size: 20px; font-weight: 900; text-shadow: 0 0 10px #000; z-index: 60;
            background: rgba(0,0,0,0.8); padding: 4px 10px; border-radius: 8px; border: 2px solid white;
            animation: popIn 0.3s forwards; pointer-events: none; white-space: nowrap;
        }
        #g-blackjack .win { color: #4f4; border-color: #4f4; }
        #g-blackjack .lose { color: #f44; border-color: #f44; }
        #g-blackjack .push { color: #ff0; border-color: #ff0; }
        #g-blackjack .bj { color: #ffd700; border-color: #ffd700; }
        #g-blackjack .charlie { color: #00e5ff; border-color: #00e5ff; }
        
        #g-blackjack #controls-bar {
            background: #000; border-top: 2px solid #333; padding: 10px;
            min-height: 90px; display: flex; align-items: center; justify-content: center; width: 100%; box-sizing: border-box;
        }
        #g-blackjack .control-group { display: none; gap: 10px; width: 100%; justify-content: center; }
        #g-blackjack .control-group.active { display: flex; }
        #g-blackjack .chip {
            width: var(--chip-size); height: var(--chip-size);
            border-radius: 50%; border: 4px dashed rgba(255,255,255,0.5);
            display: flex; align-items: center; justify-content: center;
            font-weight: bold; cursor: pointer; color: #fff; font-size: 16px;
            box-shadow: 0 4px 8px #000;
        }
        #g-blackjack .c10 { background: #007bff; } 
        #g-blackjack .c50 { background: #28a745; } 
        #g-blackjack .c100 { background: #111; color: #ffd700; border-color: #ffd700; }
        #g-blackjack .btn-action {
            padding: 15px 0; flex: 1; max-width: 100px;
            border-radius: 8px; border: none; font-weight: bold; font-size: 14px;
            color: #fff; cursor: pointer; text-transform: uppercase;
            box-shadow: 0 4px 0 rgba(0,0,0,0.3);
        }
        #g-blackjack .hit { background: #28a745; } 
        #g-blackjack .stand { background: #dc3545; }
        #g-blackjack .double { background: #ffc107; color: #000; } 
        #g-blackjack .split { background: #6f42c1; }
        #g-blackjack .deal { background: #ffd700; color: #000; max-width: 200px; font-size: 22px; }
        #g-blackjack .clear { background: #555; max-width: 60px; font-size: 11px; padding: 10px 0; }
        #g-blackjack .max { background: #ff5722; max-width: 60px; font-size: 11px; padding: 10px 0; }
        #g-blackjack .streak-pill { background: #222; border: 1px solid #ffd700; color: #ffd700; padding: 5px 10px; border-radius: 15px; font-size: 12px; }

        
        #g-hangman { background:#1e1e1e; flex-direction:column; transition: background 0.3s; }
        #g-hangman.risk-bg { background: #4a0000; }
        
        @keyframes keyShake {
            0% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            50% { transform: translateX(5px); }
            75% { transform: translateX(-5px); }
            100% { transform: translateX(0); }
        }
        .key-shaking { animation: keyShake 0.3s ease-in-out; background: #a71d2a !important; }

        #g-hangman .top-bar { 
            padding:5px 10px;
            display:grid;
            grid-template-columns: 90px 1fr auto;
            align-items:center;
            background:#2c2c2c;
            border-bottom:1px solid #444;
            min-height: 55px;
            width: 100%;
            box-sizing: border-box;
            gap: 8px;
        }
        #g-hangman .hm-left-slot{ width:90px; height: 1px; }
        #g-hangman .top-bar .cat-pill{ justify-self: center; cursor: pointer; }
        #g-hangman .hm-status{ display:flex; align-items:center; gap:10px; flex-wrap:nowrap; justify-self:end; min-width: 0; }
        #g-hangman .heart-container{ white-space: nowrap; line-height: 1; font-size: clamp(14px, 4.2vw, 18px); letter-spacing: 1px; max-width: 48vw; overflow: hidden; }
        #g-hangman .cat-pill {
            background: #333; color: #ffc107; padding: 6px 14px; border-radius: 20px;
            font-weight: bold; font-size: 14px; border: 1px solid #555; text-transform: uppercase;
        }
        #g-hangman .game-area { flex:1; display:flex; flex-direction:column; align-items:center; justify-content:center; position:relative; gap: 5px; width: 100%; }
        #g-hangman canvas { background:transparent; max-height: 22vh; width: 100%; object-fit:contain; }
        #g-hangman #hm-confetti-canvas { position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; z-index:40; }
        #g-hangman #word-display { 
            font-size: 42px; letter-spacing: 4px; margin: 5px 0; 
            font-family: monospace; font-weight:bold; color: #fff;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5); min-height: 50px; text-align: center;
            width: 100%; white-space: nowrap;
        }
        #g-hangman #hint-box {
            background: #333; color: #ffc107; 
            padding: 8px 15px; border-radius: 8px; border: 1px solid #555;
            font-size: 18px; text-align: center; font-style: italic;
            width: 85%; visibility: hidden;
            min-height: 24px; display:flex; align-items:center; justify-content:center;
        }
        #g-hangman .controls { width:100%; display:flex; justify-content:center; gap: 15px; padding-bottom:5px; margin-top:5px; }
        #g-hangman .keyboard { 
            display:grid;
            grid-template-columns: repeat(7, 1fr);
            gap:6px;
            padding:6px;
            width: min(600px, calc(100vw - 20px));
            margin: 0 auto 6px auto;
            transition: all 0.3s;
            box-sizing: border-box;
        }
        #g-hangman .keyboard.risk-active { background: rgba(255, 165, 0, 0.15); border-radius: 12px; box-shadow: 0 0 15px rgba(255, 165, 0, 0.3); }
        #g-hangman .key {
            width: auto; height: 54px; 
            background: #3a3a3a; border-bottom: 4px solid #222; color: #fff;
            border-radius: 8px; font-weight:bold; font-size:22px;
            display:flex; justify-content:center; align-items:center;
            cursor:pointer; transition: transform 0.1s, background 0.2s;
        }
        #g-hangman .key:active { transform: translateY(2px); border-bottom-width: 2px; }
        #g-hangman .key.correct { background: #28a745; border-color: #1e7e34; opacity: 0.3; pointer-events:none; }
        #g-hangman .key.wrong { background: #dc3545; border-color: #a71d2a; opacity: 0.3; pointer-events:none; }
        #g-hangman button { border:none; border-radius: 8px; font-weight:bold; cursor:pointer; font-size:16px; transition: opacity 0.2s; }
        #g-hangman .btn-blue { background:#007bff; color:white; padding: 6px 12px; font-size:14px; }
        #g-hangman .btn-hint { background:#444; color:#ddd; padding: 10px 20px; display:flex; align-items:center; gap:6px; font-size:16px; border:1px solid #666; }
        #g-hangman .btn-risk { 
            background: linear-gradient(135deg, #ffc107, #ff8c00); 
            color:#000; padding: 10px 20px; 
            display:flex; align-items:center; gap:6px; font-size:16px;
            box-shadow: 0 4px 0 #b8860b; transition: transform 0.1s;
        }
        #g-hangman .btn-risk:active { transform: translateY(2px); box-shadow: 0 2px 0 #b8860b; }
        #g-hangman .overlay { 
            position:absolute; top:0; left:0; right:0; bottom:0; 
            background:rgba(0,0,0,0.85); backdrop-filter: blur(5px); z-index:50;
            display:flex; flex-direction:column; align-items:center; justify-content:center; gap:20px; 
        }
        #g-hangman .cat-grid { display:grid; grid-template-columns: 1fr 1fr; gap:15px; width: 85%; max-width:400px; }
        #g-hangman .cat-btn { padding:20px; font-size:18px; background:#444; color:#fff; border-radius:12px; }
        #g-hangman .btn-green { background:#28a745; color:white; padding: 15px 40px; font-size: 22px; box-shadow: 0 5px 15px rgba(40, 167, 69, 0.4); }
        #g-hangman .input-group { display:flex; flex-direction:column; gap:10px; width:80%; max-width:300px; }
        #g-hangman .custom-field { 
            font-size:20px; padding:12px; text-transform:uppercase; 
            text-align:center; width: 100%; box-sizing:border-box;
            background: #333; color:#fff; border: 2px solid #555; border-radius:8px;
        }
        #hm-streak { font-size:14px; color:#ff9900; font-weight:bold; margin-right:10px; }

        
        #g-dots { background:#000; flex-direction: column; }
        #g-dots .wrap {
            height: 100%; width: 100%;
            display: flex; flex-direction: column; padding: 10px; box-sizing: border-box; gap: 10px;
        }
        #g-dots .top {
            flex: 0 0 auto; background: #222; border: 1px solid #444;
            border-radius: 12px; padding: 10px; padding-left: 90px;
            display: flex; flex-direction: column; gap: 8px; z-index: 10;
        }
        #g-dots .row { display: flex; align-items: center; justify-content: space-between; }
        #g-dots button {
            background: #444; border: 1px solid #666; color: #fff;
            font-size: 13px; font-weight: 600; padding: 8px 12px;
            border-radius: 6px; cursor: pointer;
        }
        #g-dots .pill {
            background: #333; border: 1px solid #555; padding: 6px 12px;
            border-radius: 99px; font-size: 14px; white-space: nowrap;
            display: flex; align-items: center;
        }
        #g-dots .status-pill { flex: 1; margin-left: 8px; justify-content: center; overflow: hidden; }
        #g-dots #turnDot {
            width: 14px; height: 14px; border-radius: 50%; background: #444; 
            margin-right: 10px; transition: all 0.2s ease; box-shadow: 0 0 5px rgba(0,0,0,0.5);
        }
        #g-dots .boardBox {
            flex: 1; background: #111; border: 1px solid #333; border-radius: 12px;
            position: relative; display: flex; justify-content: center; align-items: center; overflow: hidden;
        }
        #g-dots .overlay {
            position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.92); display: flex; 
            flex-direction: column; justify-content: center; align-items: center;
            z-index: 20; border-radius: 12px; gap: 20px;
        }
        #g-dots .grid-options { display: flex; flex-direction: column; gap: 10px; width: 220px; }
        #g-dots .grid-btn { padding: 14px; font-size: 16px; background: #222; border: 1px solid #555; color: #ddd; }

        #g-dots .dots-mode-row, #g-dots .dots-ai-row { display:flex; gap:10px; width: 240px; justify-content:center; }
        #g-dots .dots-mode-btn { flex: 1; font-size: 14px; padding: 12px; }
        #g-dots .dots-ai-btn { flex: 1; font-size: 14px; padding: 10px; }
        #g-dots .dots-sel { border-color:#ffd700 !important; color:#ffd700 !important; box-shadow: 0 0 0 2px rgba(255,215,0,0.35) inset; }
        #g-dots canvas { display: block; touch-action: none; border-radius: 8px; }
        #g-dots #dots-confetti-canvas { position: absolute; top:0; left:0; width:100%; height:100%; pointer-events: none; z-index: 25; }
        
        @keyframes popUpFade { 0% { opacity:0; transform:scale(0.5); } 20% { opacity:1; transform:scale(1.2); } 100% { opacity:0; transform:scale(1); } }
        #combo-text { position:absolute; font-size:3rem; font-weight:900; color:#ffd700; text-shadow:0 0 10px #000; pointer-events:none; opacity:0; }
        .combo-anim { animation: popUpFade 1s forwards; }

        
        #g-balloons { position: relative; width: 100%; height: 100%; background: linear-gradient(to bottom, #87CEEB 0%, #E0F7FA 100%); overflow: hidden; transition: background 1s; }
        body.rainbow-active #g-balloons { background: linear-gradient(45deg, #ff9a9e, #fad0c4, #fad0c4, #a18cd1, #fbc2eb, #8fd3f4); background-size: 400% 400%; animation: rb-bg 3s ease infinite; }
        @keyframes rb-bg { 0% { background-position: 0% 50%; } 50% { background-position: 100% 50%; } 100% { background-position: 0% 50%; } }
        #g-balloons canvas { display: block; width: 100%; height: 100%; }
        
        #g-balloons .b-ui { position: absolute; top: 0; left: 0; width: 100%; padding: 10px; box-sizing: border-box; pointer-events: none; display: flex; flex-direction: column; align-items: center; z-index: 10; }
        #g-balloons .b-header { display: flex; justify-content: flex-end; width: 100%; margin-top: 40px; }
        #g-balloons .b-counters { display: flex; gap: 10px; }
        #g-balloons .b-pill { background: rgba(255,255,255,0.9); color: #333; padding: 8px 18px; border-radius: 50px; font-size: 1.4rem; font-weight: 900; border: 3px solid #fff; box-shadow: 0 4px 10px rgba(0,0,0,0.2); display: flex; align-items: center; gap: 8px; }
        #g-balloons .b-meter-wrap { width: 100%; max-width: 300px; height: 18px; background: rgba(0,0,0,0.3); border: 2px solid white; border-radius: 10px; overflow: hidden; margin-top: 10px; }
        #g-balloons .b-fill { height: 100%; width: 0%; background: linear-gradient(90deg, red, orange, yellow, green, blue, indigo, violet); transition: width 0.3s; }
        #g-balloons .b-msg { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 4rem; font-weight: 900; color: #fff; text-shadow: 0 0 20px #FF00FF, 0 0 40px #00FFFF; display: none; pointer-events: none; z-index: 50; animation: bPop 0.5s forwards; }
        @keyframes bPop { 0% { transform: translate(-50%, -50%) scale(0); } 70% { transform: translate(-50%, -50%) scale(1.2); } 100% { transform: translate(-50%, -50%) scale(1); } }

#g-balloons .b-milestone { 
    position:absolute; top:50%; left:50%;
    transform:translate(-50%,-50%);
    font-size: min(18vw, 6.2rem);
    font-weight: 1000;
    text-align:center;
    line-height: 0.95;
    color:#fff;
    text-shadow: 0 0 18px rgba(0,0,0,0.55), 0 0 30px #FF00FF, 0 0 40px #00FFFF;
    display:none;
    pointer-events:none;
    z-index: 55;
}
#g-balloons .b-milestone.show { display:block; animation: bMilestone 1.2s forwards; }
@keyframes bMilestone {
    0% { opacity:0; transform: translate(-50%, -50%) scale(0.25) rotate(-10deg); }
    18% { opacity:1; transform: translate(-50%, -50%) scale(1.25) rotate(10deg); }
    55% { opacity:1; transform: translate(-50%, -50%) scale(1.05) rotate(-4deg); }
    100% { opacity:0; transform: translate(-50%, -50%) scale(1.25) rotate(0deg); }
}

body.unicorn-mega #g-balloons { animation: megaHue 0.7s linear infinite; }
@keyframes megaHue { 0%{ filter:hue-rotate(0deg) saturate(1.6); } 50%{ filter:hue-rotate(180deg) saturate(2.2); } 100%{ filter:hue-rotate(360deg) saturate(1.6);} }
body.unicorn-mega #g-balloons canvas { animation: megaShake 0.12s infinite; }
@keyframes megaShake { 0%{ transform: translate(0,0); } 25%{ transform: translate(2px,-2px); } 50%{ transform: translate(-2px,2px); } 75%{ transform: translate(2px,2px); } 100%{ transform: translate(-2px,-2px); } }
body.reduce-motion.unicorn-mega #g-balloons, body.reduce-motion.unicorn-mega #g-balloons canvas { animation:none !important; filter:none !important; }
        #g-balloons .b-start-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 60; }
        #g-balloons .big-play-btn { font-size: 2rem; padding: 20px 60px; background: linear-gradient(to bottom, #E040FB, #7C4DFF); color: white; border: 4px solid white; border-radius: 50px; cursor: pointer; box-shadow: 0 10px 20px rgba(0,0,0,0.4); animation: pulse 1.5s infinite; margin-top: 20px; }

        
        #g-minesweeper { background: #222; flex-direction: column; user-select: none; }
        #g-minesweeper .ms-top {
            flex: 0 0 60px; background: #333; width: 100%; border-bottom: 2px solid #555;
            display: flex; align-items: center; justify-content: space-between; padding: 0 20px; box-sizing: border-box;
            padding-left: 90px;
        }
        #g-minesweeper .ms-counter {
            background: #000; color: #f00; font-family: 'Courier New', monospace; font-size: 24px;
            font-weight: bold; padding: 4px 8px; border: 2px solid #555; border-radius: 4px; width: 60px; text-align: center;
        }
        #g-minesweeper .ms-face {
            font-size: 32px; background: #444; border: 2px solid #666; border-radius: 50%;
            width: 50px; height: 50px; display: flex; align-items: center; justify-content: center;
            cursor: pointer; box-shadow: 0 4px 0 rgba(0,0,0,0.3);
        }
        #g-minesweeper .ms-face:active { transform: translateY(2px); box-shadow: 0 2px 0 rgba(0,0,0,0.3); }
        
        #g-minesweeper .ms-board-wrap {
            flex: 1; display: flex; align-items: center; justify-content: center; overflow: hidden; width: 100%; padding: 10px; box-sizing: border-box; position: relative;
        }
        #g-minesweeper .ms-grid {
            display: grid; gap: 1px; background: #555; padding: 4px; border-radius: 4px; box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
        #g-minesweeper .ms-cell {
            background: #888; border: 1px solid rgba(255,255,255,0.2);
            display: flex; align-items: center; justify-content: center; font-weight: 900; 
            font-size: 100%;
            overflow: hidden;
            line-height: 1;
            cursor: pointer; position: relative;
        }
        #g-minesweeper .ms-cell.covered {
            background: linear-gradient(135deg, #aaa, #888);
            box-shadow: inset 2px 2px 0 rgba(255,255,255,0.4), inset -2px -2px 0 rgba(0,0,0,0.2);
        }
        #g-minesweeper .ms-cell.covered:hover { background: #bbb; }
        #g-minesweeper .ms-cell.revealed { background: #bbb; border: 1px solid #999; }
        #g-minesweeper .ms-cell.mine { background: #f44; border: 1px solid #d00; }
        
        #g-minesweeper .c1 { color: #00f; }
        #g-minesweeper .c2 { color: #008000; }
        #g-minesweeper .c3 { color: #f00; }
        #g-minesweeper .c4 { color: #000080; }
        #g-minesweeper .c5 { color: #800000; }
        #g-minesweeper .c6 { color: #008080; }
        #g-minesweeper .c7 { color: #000; }
        #g-minesweeper .c8 { color: #808080; }

        #g-minesweeper .btn-opt {
            background: #444; color: #fff; padding: 15px 30px; border: 1px solid #666;
            font-size: 18px; width: 220px; border-radius: 8px; cursor: pointer; text-align: center;
        }
        #g-minesweeper .btn-opt:hover { background: #555; border-color: #fff; }

        
        #g-clock { background: #2c3e50; flex-direction: column; align-items: center; justify-content: center; }
        #g-clock .clock-face { 
            background: #fff; border-radius: 50%; border: 10px solid #333;
            box-shadow: 0 10px 20px rgba(0,0,0,0.5); margin-bottom: 20px;
        }
        #g-clock .clock-ui { display: flex; flex-direction: column; align-items: center; gap: 10px; width: 100%; }
        #g-clock .display-box {
            font-size: 30px; font-weight: bold; background: #fff; color: #000;
            padding: 10px 20px; border-radius: 8px; min-width: 120px; text-align: center;
        }
        #g-clock .mc-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; width: 90%; max-width: 400px; }
        #g-clock .mc-btn { 
            background: #34495e; color: #ecf0f1; padding: 15px; border-radius: 8px; 
            border: 2px solid #2c3e50; font-size: 24px; cursor: pointer;
        }
        #g-clock .mc-btn:active { background: #2c3e50; }
        
        
        #g-math { background: #8e44ad; flex-direction: column; align-items: center; justify-content: center; }
        #g-math .math-box {
            background: rgba(255,255,255,0.1); border-radius: 20px; padding: 15px;
            width: 95%; max-width: 500px; display: flex; flex-direction: column; align-items: center;
            border: 2px solid rgba(255,255,255,0.2); text-align: center;
            height: 90vh; justify-content: center;
        }
        #g-math .problem { font-size: 3rem; font-weight: bold; margin: 10px 0; text-shadow: 0 2px 4px rgba(0,0,0,0.3); }
        #g-math .word-problem { font-size: 1.5rem; margin: 10px 0; line-height: 1.4; padding: 0 10px; }
        #g-math .math-display {
            font-size: 2.5rem; padding: 10px; width: 180px; text-align: center;
            background: rgba(0,0,0,0.3); color: #fff;
            border-radius: 10px; border: 2px solid rgba(255,255,255,0.3); margin-bottom: 10px;
            min-height: 60px; display: flex; align-items: center; justify-content: center;
        }

        
        #g-tictactoe { background: radial-gradient(circle at center, #1a1a1a 0%, #000 80%); flex-direction: column; }
        #g-tictactoe .ttt-top {
            height: 60px; width: 100%;
            display: flex; align-items: center; justify-content: center;
            background: rgba(0,0,0,0.7); border-bottom: 1px solid rgba(255,255,255,0.15);
            box-sizing: border-box; padding-left: 90px;
            gap: 12px;
        }
        #g-tictactoe .ttt-pill {
            background: #222; border: 1px solid #444; color: #fff;
            padding: 6px 12px; border-radius: 999px; font-weight: 800; letter-spacing: 0.5px;
            display: flex; align-items: center; gap: 10px;
        }
        #g-tictactoe .ttt-score { font-family: monospace; color: #ffd700; }
        #g-tictactoe .ttt-wrap { flex: 1; display:flex; align-items:center; justify-content:center; padding: 20px; box-sizing: border-box; }
        #g-tictactoe .ttt-board {
            width: min(88vw, 420px); height: min(88vw, 420px);
            display: grid; grid-template-columns: repeat(3, 1fr); grid-template-rows: repeat(3, 1fr);
            gap: 10px; padding: 12px;
            background: rgba(255,255,255,0.05); border: 2px solid rgba(255,255,255,0.12);
            border-radius: 18px; box-shadow: 0 0 25px rgba(0,0,0,0.6);
        }
        #g-tictactoe .ttt-cell {
            background: linear-gradient(145deg, #2a2a2a, #111);
            border: 2px solid rgba(255,255,255,0.12);
            border-bottom-width: 6px;
            border-radius: 14px;
            display:flex; align-items:center; justify-content:center;
            font-weight: 900; font-size: clamp(40px, 9vw, 90px);
            cursor: pointer; user-select: none;
            transition: transform 0.08s, border-color 0.2s, background 0.2s;
        }
        #g-tictactoe .ttt-cell:active { transform: scale(0.98); }
        #g-tictactoe .ttt-x { color: #ff5252; text-shadow: 0 0 14px rgba(255,82,82,0.35); }
        #g-tictactoe .ttt-o { color: #00e5ff; text-shadow: 0 0 14px rgba(0,229,255,0.35); }
        #g-tictactoe .ttt-win {
            border-color: #ffd700 !important;
            box-shadow: 0 0 20px rgba(255,215,0,0.35);
            background: linear-gradient(145deg, #3a3200, #1a1400) !important;
        }
        #g-tictactoe .ttt-mini {
            display: flex; gap: 10px; margin-top: 12px; justify-content: center;
        }
        #g-tictactoe .ttt-btn {
            background: #333; border: 1px solid #666; color: #fff;
            padding: 10px 14px; border-radius: 10px; cursor: pointer; font-weight: 800;
        }
        #g-tictactoe .ttt-btn:active { transform: scale(0.98); }
        #g-tictactoe .ttt-sub { color: #aaa; font-size: 14px; text-align: center; max-width: 420px; }

        
        #g-maze { background: radial-gradient(circle at 30% 20%, #0b1a2b 0%, #000 70%); flex-direction: column; }
        #g-maze .mz-top {
            height: 60px; width: 100%;
            display: flex; align-items: center; justify-content: space-between;
            background: rgba(0,0,0,0.7); border-bottom: 1px solid rgba(255,255,255,0.15);
            box-sizing: border-box; padding: 0 12px; padding-left: 90px;
            gap: 10px;
        }
        #g-maze .mz-left, #g-maze .mz-right { display:flex; align-items:center; gap: 10px; }
        #g-maze .mz-pill {
            background: #122034; border: 1px solid rgba(255,255,255,0.18);
            padding: 6px 12px; border-radius: 999px; font-weight: 900; letter-spacing: 0.5px;
            display:flex; align-items:center; gap: 8px;
        }
        #g-maze .mz-pill span { font-family: monospace; color: #ffd700; }
        #g-maze .mz-btn {
            background: #1b2e4b; border: 1px solid rgba(255,255,255,0.22);
            color: #fff; padding: 8px 12px; border-radius: 10px; cursor: pointer; font-weight: 800;
        }
        #g-maze .mz-btn:active { transform: scale(0.98); }
        #g-maze .mz-wrap {
            flex: 1; display:flex; flex-direction: column;
            align-items:center; justify-content: center; gap: 10px;
            padding: 10px; box-sizing: border-box;
        }
        #g-maze .mz-canvas-wrap {
            flex: 1; width: 100%; max-width: 740px;
            background: rgba(255,255,255,0.04);
            border: 1px solid var(--ui-border);
            border-radius: var(--ui-radius);
            display:flex; align-items:center; justify-content:center;
            position: relative;
            overflow: hidden;
        }
        #g-maze canvas { width: 100%; height: 100%; display:block; touch-action: none; }
        #g-maze .mz-pad {
            flex: 0 0 auto;
            width: min(360px, 92vw);
            display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px;
            margin-bottom: 8px;
        }
        #g-maze .mz-pad .mz-pad-btn {
            background: rgba(0,0,0,0.55); border: 2px solid rgba(255,255,255,0.18);
            color: #fff; border-radius: var(--ui-radius);
            font-size: 24px; font-weight: 900;
            height: 62px; cursor:pointer; user-select:none;
            display:flex; align-items:center; justify-content:center;
        }
        #g-maze .mz-pad .mz-pad-btn:active { transform: scale(0.98); background: rgba(255,255,255,0.12); }
        #g-maze .mz-pad .blank { opacity: 0; pointer-events:none; }
        #g-maze .mz-hint {
            color: rgba(255,255,255,0.7);
            font-size: 13px; text-align: center;
            margin-top: -4px;
        }

        
        #g-checkers { background: radial-gradient(circle at center, #1b0b0b 0%, #000 75%); flex-direction: column; }
        #g-checkers .ck-top {
            height: 60px; width: 100%;
            display: flex; align-items: center; justify-content: space-between;
            background: rgba(0,0,0,0.7); border-bottom: 1px solid rgba(255,255,255,0.15);
            box-sizing: border-box; padding: 0 12px; padding-left: 90px;
        }
        #g-checkers .ck-pill {
            background: #2a1111; border: 1px solid rgba(255,255,255,0.18);
            padding: 6px 12px; border-radius: 999px; font-weight: 900; letter-spacing: 0.5px;
            display:flex; align-items:center; gap: 10px;
        }
        #g-checkers .ck-pill .ck-turn { color: #ffd700; font-family: monospace; }
        #g-checkers .ck-btn {
            background: #3a1616; border: 1px solid rgba(255,255,255,0.22);
            color: #fff; padding: 8px 12px; border-radius: 10px; cursor: pointer; font-weight: 800;
        }
        #g-checkers .ck-btn:active { transform: scale(0.98); }
        #g-checkers .ck-wrap {
            flex: 1; display:flex; flex-direction: column; align-items:center; justify-content:center;
            padding: 12px; box-sizing:border-box; gap: 10px;
        }
        #g-checkers .ck-board-wrap {
            width: min(92vw, 560px);
            aspect-ratio: 1 / 1;
            background: rgba(255,255,255,0.04);
            border: 1px solid var(--ui-border);
            border-radius: var(--ui-radius);
            overflow: hidden;
            box-shadow: 0 0 25px rgba(0,0,0,0.6);
        }
        #g-checkers canvas { width: 100%; height: 100%; display:block; touch-action: none; }
        #g-checkers .ck-sub {
            color: rgba(255,255,255,0.75);
            font-size: 13px; text-align:center;
            max-width: 560px;
        }

        
        #g-simon { background: radial-gradient(circle at center, #0a0a0a 0%, #000 80%); flex-direction: column; }
        #g-simon .si-top {
            height: 60px; width: 100%;
            display: flex; align-items: center; justify-content: space-between;
            background: rgba(0,0,0,0.7); border-bottom: 1px solid rgba(255,255,255,0.15);
            box-sizing: border-box; padding: 0 12px; padding-left: 90px;
        }
        #g-simon .si-pill {
            background: #1a1a1a; border: 1px solid rgba(255,255,255,0.18);
            padding: 6px 12px; border-radius: 999px; font-weight: 900; letter-spacing: 0.5px;
            display:flex; align-items:center; gap: 10px;
        }
        #g-simon .si-pill span { color: #ffd700; font-family: monospace; }
        #g-simon .si-btn {
            background: #222; border: 1px solid rgba(255,255,255,0.22);
            color: #fff; padding: 8px 12px; border-radius: 10px; cursor: pointer; font-weight: 800;
        }
        #g-simon .si-btn:active { transform: scale(0.98); }
        #g-simon .si-wrap {
            flex: 1; display:flex; flex-direction: column;
            align-items:center; justify-content:center; padding: 18px; gap: 14px;
        }
        #g-simon .si-board {
            width: min(84vw, 460px); aspect-ratio: 1 / 1;
            display:grid; grid-template-columns: 1fr 1fr; grid-template-rows: 1fr 1fr;
            gap: 14px; padding: 14px;
            border-radius: 22px;
            background: rgba(255,255,255,0.03);
            border: 1px solid var(--ui-border);
            box-shadow: 0 0 25px rgba(0,0,0,0.7);
        }
        #g-simon .si-pad {
            border-radius: 18px;
            border: 2px solid rgba(255,255,255,0.12);
            cursor: pointer;
            user-select:none;
            display:flex; align-items:center; justify-content:center;
            font-weight: 900; letter-spacing: 1px;
            font-size: 18px;
            text-shadow: 0 0 12px rgba(0,0,0,0.6);
            transition: transform 0.08s, filter 0.1s, box-shadow 0.1s;
        }
        #g-simon .si-pad:active { transform: scale(0.98); }
        #g-simon .si-pad.on { filter: brightness(1.55) saturate(1.2); box-shadow: 0 0 20px rgba(255,255,255,0.15); }
        #g-simon .si-green { background: linear-gradient(145deg, #1f8a3a, #0e3f1a); }
        #g-simon .si-red   { background: linear-gradient(145deg, #b02a2a, #4a0f0f); }
        #g-simon .si-blue  { background: linear-gradient(145deg, #2b63c9, #0f244a); }
        #g-simon .si-yellow{ background: linear-gradient(145deg, #caa71f, #4a3c0f); color: #111; text-shadow:none; }
        #g-simon .si-controls { display:flex; gap: 10px; flex-wrap: wrap; justify-content:center; }
        #g-simon .si-toggle {
            background: #111; border: 1px solid rgba(255,255,255,0.18);
            border-radius: 999px; padding: 8px 12px;
            display:flex; align-items:center; gap: 10px;
            font-weight: 900;
        }
        #g-simon .si-dot {
            width: 14px; height: 14px; border-radius: 50%;
            background: #444; box-shadow: 0 0 8px rgba(0,0,0,0.7);
            transition: background 0.2s, box-shadow 0.2s;
        }
        #g-simon .si-dot.on { background: #ff5252; box-shadow: 0 0 12px rgba(255,82,82,0.7); }
        #g-simon .si-hint { color: rgba(255,255,255,0.7); font-size: 13px; text-align:center; max-width: 520px; }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
    

        
        #g-minigolf { background: radial-gradient(circle at 30% 20%, #143312 0%, #000 75%); flex-direction: column; }
        #g-minigolf .mg-top {
            height: 60px; width: 100%;
            display: flex; align-items: center; justify-content: space-between;
            background: rgba(0,0,0,0.7); border-bottom: 1px solid rgba(255,255,255,0.15);
            box-sizing: border-box; padding: 0 12px; padding-left: 90px; gap: 10px;
        }
        #g-minigolf .mg-left, #g-minigolf .mg-right { display:flex; align-items:center; gap: 10px; flex-wrap: wrap; }
        #g-minigolf .mg-pill {
            background: #1c3b1a; border: 1px solid rgba(255,255,255,0.18);
            padding: 6px 12px; border-radius: 999px; font-weight: 900; letter-spacing: 0.5px;
            display:flex; align-items:center; gap: 8px;
        }
        #g-minigolf .mg-pill span { font-family: monospace; color: #ffd700; }
        #g-minigolf .mg-btn {
            background: #21401e; border: 1px solid rgba(255,255,255,0.22);
            color: #fff; padding: 8px 12px; border-radius: 10px; cursor: pointer; font-weight: 800;
        }
        #g-minigolf .mg-btn:active { transform: scale(0.98); }
        #g-minigolf .mg-wrap {
            flex: 1; display:flex; flex-direction: column;
            align-items:center; justify-content:center;
            padding: 12px; box-sizing:border-box; gap: 10px;
        }
        #g-minigolf .mg-canvas-wrap {
            flex: 1; width: 100%; max-width: 920px;
            background: rgba(255,255,255,0.04);
            border: 1px solid var(--ui-border);
            border-radius: var(--ui-radius);
            overflow: hidden;
            box-shadow: 0 0 25px rgba(0,0,0,0.6);
            position: relative;
        }
        #g-minigolf canvas { width: 100%; height: 100%; display:block; touch-action: none; }
        #g-minigolf .mg-bottom {
            width: 100%; max-width: 920px;
            display:flex; flex-direction: column; align-items:center; gap: 8px;
        }
        #g-minigolf .mg-power-row { display:flex; align-items:center; justify-content:center; gap: 10px; flex-wrap: wrap; width: 100%; }
        #g-minigolf .mg-bar {
            display: none; 
            width: min(360px, 92vw); height: 18px;
            background: rgba(255,255,255,0.12);
            border: 1px solid rgba(255,255,255,0.25);
            border-radius: 999px; overflow: hidden;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.5);
        }
        #g-minigolf .mg-fill {
            height: 100%; width: 0%;
            background: linear-gradient(90deg, #00e5ff, #ffd700, #ff5252);
            transition: width 0.03s;
        }
        #g-minigolf .mg-hint {
            color: rgba(255,255,255,0.75);
            font-size: 13px; text-align:center;
            max-width: 780px;
        }

        #g-minigolf #mg-hole-overlay,
        #g-minigolf #mg-round-overlay{
            
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            padding: 34px 18px;
            overflow: auto;
            justify-content: center;
            background: rgba(0,0,0,0.92);
            z-index: 120;
        }
        #g-minigolf #mg-hole-overlay .splash-title,
        #g-minigolf #mg-round-overlay .splash-title{ margin-top: 10px; }

        
        
        
        #g-minigolf .mg-power-row.mg-controls{
            justify-content: center;
            gap: 12px;
        }
        #g-minigolf .mg-stick{
            width: 92px; height: 92px;
            border-radius: 50%;
            border: 1px solid rgba(255,255,255,0.25);
            background: rgba(0,0,0,0.22);
            box-shadow: inset 0 0 14px rgba(0,0,0,0.55), 0 0 18px rgba(0,0,0,0.35);
            position: relative;
            touch-action: none;
            user-select: none;
            flex: 0 0 auto;
        }
        #g-minigolf .mg-stick::after{
            content: "AIM";
            position:absolute;
            left: 50%; top: 50%;
            transform: translate(-50%, -50%);
            font-size: 12px;
            letter-spacing: 1px;
            color: rgba(255,255,255,0.55);
            font-weight: 900;
            pointer-events: none;
        }
        #g-minigolf .mg-stick-knob{
            width: 28px; height: 28px;
            border-radius: 50%;
            background: rgba(0,229,255,0.90);
            box-shadow: 0 0 12px rgba(0,229,255,0.35);
            position: absolute;
            left: 50%; top: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }
        #g-minigolf .mg-power-col{
            display:flex;
            flex-direction: column;
            align-items:center;
            gap: 6px;
        }
        #g-minigolf #mg-power-slider{
            width: min(300px, 78vw);
            accent-color: #00e5ff;
        }
        #g-minigolf .mg-btn.mg-shoot{
            background: rgba(0,229,255,0.22);
            border-color: rgba(0,229,255,0.55);
        }
@media (max-width: 640px){
            .menu-grid { grid-template-columns: repeat(3, 1fr); }
        }
        @media (max-width: 420px){
            .menu-grid { grid-template-columns: repeat(2, 1fr); }
            .menu-title { font-size: 2.0rem; }
            .game-card { height: 84px; }
        }

        
#g-trail { background: radial-gradient(circle at 60% 30%, #1c1230, #050509); }
        #g-trail .trail-wrap{
            position: relative;
            width: 100%; height: 100%;
            padding-top: 48px;
            box-sizing: border-box;
        }
        #g-trail .trail-hud{
            position:absolute;
            left: 12px; right: 12px; top: 48px;
            background: rgba(0,0,0,0.28);
            border: 1px solid var(--ui-border);
            border-radius: var(--ui-radius);
            padding: 8px 10px;
            backdrop-filter: blur(6px);
            z-index: 5;
        }
        #g-trail .trail-title{ font-weight: 900; letter-spacing: 1px; font-size: 15px; }
        #g-trail .trail-sub{ margin-top: 4px; color:#cfcfcf; font-size: 0.82rem; }
        #g-trail .trail-row{ margin-top: 6px; display:flex; gap: 8px; align-items:center; flex-wrap:wrap; }
        #g-trail .trail-spacer{ flex: 1; }
        #g-trail .trail-mode{ padding: 10px 12px; font-size:  13px; }
        #g-trail .trail-action{ padding: 10px 12px; font-size:  13px; }
        #g-trail .trail-active{ background: rgba(0,229,255,0.20); border-color: rgba(0,229,255,0.52); }

        #g-trail .trail-top{ display:flex; align-items:center; justify-content:space-between; gap:10px; }
        #g-trail .trail-top-actions{ display:flex; align-items:center; gap:10px; }
        #g-trail .trail-quick-next{ padding: 10px 14px; font-size: 13px; font-weight: 900; }
        #g-trail .trail-menu-btn{ padding: 10px 14px; font-size:  16px; line-height: 1; }
        #g-trail .trail-quick-erase{ padding: 10px 14px; font-size:  13px; font-weight: 900; }
        #g-trail .trail-hud.trail-collapsed{ padding: 6px 10px; }
        #g-trail .trail-hud.trail-collapsed .trail-sub,
        #g-trail .trail-hud.trail-collapsed .trail-row{ display:none; }
        #g-trail .trail-hud.trail-collapsed .trail-title{ font-size: 14px; }

        #trail-canvas{
            position:absolute; left:0; top:0;
            width: 100%; height: 100%;
            touch-action: none;
        }

        
        #g-orbslicer { background: radial-gradient(circle at 50% 18%, #1e90ff, #2b1055 60%, #050509); }
        #orb-canvas{
            position:absolute; left:0; top:0;
            width:100%; height:100%;
            touch-action:none;
        }
        #g-orbslicer .orb-ui{
            position:absolute;
            left: 12px; right: 12px; top: 48px;
            display:flex;
            align-items:center;
            justify-content: space-between;
            gap: 10px;
            z-index: 8;
            pointer-events:none;
        }
        #g-orbslicer .orb-pill{
            background: rgba(0,0,0,0.28);
            border: 1px solid var(--ui-border);
            border-radius: 999px;
            padding: 8px 12px;
            font-weight: 900;
            font-size: 15px;
            letter-spacing: 0.6px;
            backdrop-filter: blur(6px);
            text-shadow: 0 2px 0 rgba(0,0,0,0.45);
            white-space: nowrap;
        }
        #g-orbslicer .orb-lives{
            color:#ff4d4d;
            font-size: 18px;
            letter-spacing: 1px;
        }
        #g-orbslicer .orb-bestline{
            color: rgba(255,255,255,0.72);
            font-weight: 900;
            letter-spacing: 1px;
            margin-top: -6px;
        }
        #g-orbslicer .orb-sub{
            max-width: 360px;
            text-align:center;
            color:#cfcfcf;
            font-size: 0.98rem;
            line-height: 1.25;
            padding: 0 18px;
        }

        #g-orbslicer .orb-diff{ display:flex; flex-direction:column; align-items:center; gap: 8px; margin-top: -6px; }
        #g-orbslicer .orb-diff-label{ font-size: 13px; font-weight: 900; letter-spacing: 1px; color: rgba(255,255,255,0.75); text-transform: uppercase; }
        #g-orbslicer .orb-diff-row{ display:flex; flex-wrap:wrap; justify-content:center; gap: 8px; padding: 0 18px; }
        #g-orbslicer .orb-diff-btn{ padding: 9px 12px; font-size: 13px; border-radius: 999px; }
        #g-orbslicer .orb-diff-btn.active{ background: rgba(0,229,255,0.20); border-color: rgba(0,229,255,0.55); }

.back-btn{
  position: fixed !important;
  top: calc(env(safe-area-inset-top, 0px) + 10px) !important;
  left: calc(env(safe-area-inset-left, 0px) + 10px) !important;
  touch-action: none;
  cursor: grab;
}
.back-btn.dragging{ cursor: grabbing; }
#global-settings-btn{
  top: calc(env(safe-area-inset-top, 0px) + 10px) !important;
  right: calc(env(safe-area-inset-right, 0px) + 10px) !important;
  touch-action: none;
  cursor: grab;
}
#global-settings-btn.dragging{ cursor: grabbing; }
.modal-screen{
  max-height: calc(100vh - 110px);
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
  padding-bottom: max(18px, env(safe-area-inset-bottom, 0px));
}
#global-settings-modal .settings-panel{
  max-height: calc(100vh - 28px);
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
  padding-bottom: max(12px, env(safe-area-inset-bottom, 0px));
}

        .back-btn.dragging, #global-settings-btn.dragging{ cursor: grabbing; }
        .back-btn, #global-settings-btn{ cursor: grab; touch-action: none; }
        .modal-screen{ max-height: calc(100vh - 120px); overflow-y: auto; -webkit-overflow-scrolling: touch; padding-bottom: max(16px, env(safe-area-inset-bottom, 0px)); }
        #global-settings-modal .settings-panel{ max-height: calc(100vh - 28px); overflow-y: auto; -webkit-overflow-scrolling: touch; }

.modal-screen{
  max-height: calc(100vh - 120px);
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
}
#global-settings-modal .settings-panel{
  max-height: calc(100vh - 28px);
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
  padding-bottom: max(12px, env(safe-area-inset-bottom));
}
.back-btn{
  position: fixed !important;
  top: calc(env(safe-area-inset-top, 0px) + 10px) !important;
  left: calc(env(safe-area-inset-left, 0px) + 10px) !important;
  touch-action: none;
}
.back-btn.dragging, #global-settings-btn.dragging{ cursor: grabbing; }

        .splash-title{ color:#ffd700 !important; text-shadow:0 0 16px rgba(255,215,0,0.25) !important; }
        [id$="-menu"].overlay, #menuOverlay, #startOverlay, #cat-menu, #g-balloons .b-start-overlay{ background: rgba(0,0,0,0.95) !important; }
        #cat-menu .menu-title, #startOverlay .panel h1, #g-balloons .b-start-overlay h1{ color:#ffd700 !important; text-shadow:0 0 18px rgba(255,215,0,0.35) !important; }
        #startOverlay .big-btn, #startOverlay .small, #cat-menu .cat-btn, #g-balloons .b-start-overlay .btn-large-opt{ background:#333 !important; border:2px solid #555 !important; border-radius:15px !important; color:#fff !important; font-weight:900 !important; box-shadow:none !important; }
        #g-balloons .b-start-overlay .btn-large-opt{ font-size: 1.9rem !important; padding: 20px 28px !important; max-width: 320px; width: 80%; }
    

        
        #g-minigolf #mg-menu{
            position: fixed !important;
            inset: 0 !important;
            border-radius: 0 !important;
            z-index: 2000 !important;
            padding:
              max(24px, calc(env(safe-area-inset-top, 0px) + 18px))
              18px
              max(24px, calc(env(safe-area-inset-bottom, 0px) + 18px))
              18px !important;
            overflow-y: auto !important;
            -webkit-overflow-scrolling: touch;
        }


        .mg-diff-btn{ padding: 10px 14px; font-size: 14px; font-weight: 900; border-radius: var(--ui-radius); }
        .mg-diff-btn.active{ border-color: rgba(0,229,255,0.9); box-shadow: 0 0 0 2px rgba(0,229,255,0.22); }
</style>
</head>
<body>

    <div id="feedback-overlay">
        <div id="feedback-content">AWESOME!</div>
        <canvas id="feedback-confetti" style="position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none;"></canvas>
    </div>

    <button id="global-settings-btn" class="ui-btn" onclick="ArcadeSettings.openModal()" title="Settings" aria-label="Settings"></button>

    <div id="global-settings-modal" role="dialog" aria-modal="true" aria-label="Arcade settings">
        <div class="settings-panel">
            <div class="settings-head">
                <div class="settings-title">SETTINGS</div>
                <button class="ui-btn settings-close" onclick="ArcadeSettings.closeModal()"></button>
            </div>

            <div class="settings-row">
                <div class="label">
                    <div class="name">Sound</div>
                    <div class="desc">Mute all game sounds</div>
                </div>
                <input id="set-sound" type="checkbox" />
            </div>

            <div class="settings-row">
                <div class="label">
                    <div class="name">Reduced motion</div>
                    <div class="desc">Turns off most UI animations and win confetti.</div>
                </div>
                <input id="set-motion" type="checkbox" />
            </div>

            <div class="settings-row">
                <div class="label">
                    <div class="name">High contrast</div>
                    <div class="desc">Stronger borders + clearer UI. Also syncs Dots contrast.</div>
                </div>
                <input id="set-contrast" type="checkbox" />
            </div>

            <div class="settings-row">
                <div class="label">
                    <div class="name">Left-handed mode</div>
                    <div class="desc">Swaps the corner buttons (Menu + Settings).</div>
                </div>
                <input id="set-handed" type="checkbox" />
            </div>

            <div class="settings-actions">
                <button class="ui-btn" onclick="ArcadeSettings.reset()">Reset</button>
                <button class="ui-btn" onclick="ArcadeSettings.closeModal()">Done</button>
            </div>
        </div>
    </div>

    <div id="g-minigolf" class="game-view">
        <button class="back-btn" onclick="goToMenu()"> MENU</button>
        <div class="mg-top">
            <div class="mg-left">
                <div class="mg-pill">HOLE <span id="mg-hole">1</span>/18</div>
                <div class="mg-pill">PAR <span id="mg-par">3</span></div>
                <div class="mg-pill">STROKES <span id="mg-strokes">0</span></div>
            </div>
            <div class="mg-right">
                <div class="mg-pill">TOTAL <span id="mg-total">0</span></div>
                <button class="mg-btn" onclick="MiniGolf.openMenu()">Menu</button>
            </div>
        </div>

        <div class="mg-wrap">
            <div class="mg-canvas-wrap">
                <canvas id="mg-canvas"></canvas>

                <div id="mg-float-msg" style="position:absolute; left:50%; top:16%; transform:translate(-50%,-50%); font-weight:900; font-size:22px; color:#fff; text-shadow:0 0 18px #000; pointer-events:none; display:none; background:rgba(0,0,0,0.55); border:1px solid rgba(255,255,255,0.2); padding:8px 14px; border-radius:12px;"></div>

                <div id="mg-menu" class="overlay" style="text-align:center;">
                    <h1 class="splash-title" style="margin:0;">MINI GOLF</h1>
                    <div style="color:#aaa; max-width:520px; padding:0 18px;">
                        Use the aim stick (or tap the course) to aim. Set power, then press SHOOT.
                        Bounce shots off walls and bumpers  slow rolls into the cup are your friend.
                    </div>
                    <div id="mg-best-line" style="color:#aaa; max-width:520px; padding:0 18px; margin-top:10px; text-align:center;">
                        Best (18 holes): <span id="mg-best-total" style="color:#ffd700; font-family:monospace;"></span>
                    </div>

                    
                    <div id="mg-diff-wrap" style="margin-top:14px; display:flex; flex-direction:column; align-items:center; gap:10px; width:100%;">
                        <div style="color:#aaa; font-weight:900; letter-spacing:1.2px;">AIM ASSIST</div>
                        <div style="display:flex; gap:10px; flex-wrap:wrap; justify-content:center;">
                            <button id="mg-diff-easy" class="ui-btn mg-diff-btn" onclick="MiniGolf.setDifficulty('easy')">EASY</button>
                            <button id="mg-diff-medium" class="ui-btn mg-diff-btn" onclick="MiniGolf.setDifficulty('medium')">MEDIUM</button>
                            <button id="mg-diff-hard" class="ui-btn mg-diff-btn" onclick="MiniGolf.setDifficulty('hard')">HARD</button>
                        </div>
                        <div style="color:#777; max-width:560px; padding:0 18px; font-size:13px; line-height:1.35;">
                            Easy shows the full predicted bounce path. Medium shows a shorter hint. Hard hides the dotted prediction.
                        </div>
                    </div>

<div style="display:flex; flex-direction:column; gap:20px; width:100%; align-items:center;">
                        <button class="btn-large-opt" onclick="MiniGolf.startOrContinue()">PLAY</button>
                        <button class="btn-large-opt" onclick="MiniGolf.restartRound()">RESTART ROUND</button>
                        <button class="btn-large-opt" style="background:#444" onclick="goToMenu()">Back to Menu</button>
                    </div>
                </div>

                <div id="mg-hole-overlay" class="overlay" style="display:none; text-align:center;">
                    <h1 id="mg-hole-title" class="splash-title" style="margin:0;">HOLE COMPLETE!</h1>
                    <div id="mg-hole-sub" style="color:#ffd700; font-family:monospace; font-size:22px;">Strokes: 0 (Par 0)</div>
                    <div style="display:flex; flex-direction:column; gap:20px; width:100%; align-items:center;">
                        <button class="btn-large-opt" onclick="MiniGolf.nextHole()">NEXT HOLE</button>
                        <button class="btn-large-opt" onclick="MiniGolf.restartHole()">REPLAY HOLE</button>
                        <button class="btn-large-opt" style="background:#444" onclick="MiniGolf.restartRound()">RESTART ROUND</button>
                    </div>
                </div>

                <div id="mg-round-overlay" class="overlay" style="display:none; text-align:center;">
                    <h1 class="splash-title" style="margin:0;">ROUND COMPLETE!</h1>
                    <div id="mg-round-sub" style="color:#ffd700; font-family:monospace; font-size:22px;">Total: 0 (0)</div>
                    <div style="display:flex; flex-direction:column; gap:20px; width:100%; align-items:center;">
                        <button class="btn-large-opt" onclick="MiniGolf.restartRound()">PLAY AGAIN</button>
                        <button class="btn-large-opt" style="background:#444" onclick="goToMenu()">Back to Menu</button>
                    </div>
                </div>
            </div>

            <div class="mg-bottom">
                <div class="mg-power-row mg-controls">
                    <div class="mg-stick" id="mg-stick"><div class="mg-stick-knob" id="mg-stick-knob"></div></div>
                    <div class="mg-power-col">
                        <div class="mg-bar"><div id="mg-power" class="mg-fill"></div></div>
                        <input id="mg-power-slider" type="range" min="0" max="100" value="35" />
                    </div>
                    <button class="mg-btn mg-shoot" id="mg-shoot-btn" onclick="MiniGolf.shoot()">SHOOT</button>
                    <button class="mg-btn" onclick="MiniGolf.restartHole()">Restart</button>
                </div>
                <div class="mg-hint">Tip: aim with the stick (or tap the course). Use the power slider, then press SHOOT. Sand slows you down; water is a penalty + reset.</div>
            </div>
        </div>
    </div>

<script>

    
    const ArcadeSettings = (function(){
        const KEY = "arcade_settings_v1";
        const defaults = { soundOn: true, reduceMotion: false, highContrast: false, swapCorners: false };
        let s = { ...defaults };
        const audioCtxs = new Set();

        function safeParse(raw){
            try{ return JSON.parse(raw); }catch(e){ return null; }
        }
        function load(){
            const raw = localStorage.getItem(KEY);
            const obj = raw ? safeParse(raw) : null;
            if(obj && typeof obj === 'object'){
                s = { ...s, ...obj };
            }
            apply();
        }
        function save(){
            try{ localStorage.setItem(KEY, JSON.stringify(s)); }catch(e){}
        }
        function apply(){
            document.body.classList.toggle('reduce-motion', !!s.reduceMotion);
            document.body.classList.toggle('high-contrast', !!s.highContrast);
            document.body.classList.toggle('swap-corners', !!s.swapCorners);

            
            audioCtxs.forEach(ctx => {
                try{
                    if(!ctx) return;
                    if(s.soundOn){
                        if(ctx.state === 'suspended') ctx.resume();
                    } else {
                        if(ctx.state === 'running') ctx.suspend();
                    }
                }catch(e){}
            });
        }
        function set(patch){
            s = { ...s, ...patch };
            save();
            apply();
            syncModal();
        }
        function reset(){
            s = { ...defaults };
            save();
            apply();
            syncModal();
        }
        function registerAudioCtx(ctx){
            if(!ctx) return;
            audioCtxs.add(ctx);
            apply();
        }

        function syncModal(){
            const modal = document.getElementById('global-settings-modal');
            const sound = document.getElementById('set-sound');
            const motion = document.getElementById('set-motion');
            const contrast = document.getElementById('set-contrast');
            const handed = document.getElementById('set-handed');
            if(!modal || !sound || !motion || !contrast || !handed) return;
            sound.checked = !!s.soundOn;
            motion.checked = !!s.reduceMotion;
            contrast.checked = !!s.highContrast;
            handed.checked = !!s.swapCorners;
        }

        function openModal(){
            const modal = document.getElementById('global-settings-modal');
            if(!modal) return;
            syncModal();
            modal.style.display = 'flex';
        }
        function closeModal(){
            const modal = document.getElementById('global-settings-modal');
            if(!modal) return;
            modal.style.display = 'none';
        }

        
        function initUI(){
            load();

            const modal = document.getElementById('global-settings-modal');
            const btn = document.getElementById('global-settings-btn');

            const sound = document.getElementById('set-sound');
            const motion = document.getElementById('set-motion');
            const contrast = document.getElementById('set-contrast');
            const handed = document.getElementById('set-handed');

            [sound, motion, contrast, handed].forEach(el => {
                if(!el) return;
                el.addEventListener('change', () => {
                    set({
                        soundOn: !!sound.checked,
                        reduceMotion: !!motion.checked,
                        highContrast: !!contrast.checked,
                        swapCorners: !!handed.checked
                    });
                });
            });

            if(modal){
                modal.addEventListener('click', (e) => {
                    if(e.target === modal) closeModal();
                });
            }

        }

        
        return {
            get soundOn(){ return !!s.soundOn; },
            get reduceMotion(){ return !!s.reduceMotion; },
            get highContrast(){ return !!s.highContrast; },
            get swapCorners(){ return !!s.swapCorners; },
            set, reset, apply, registerAudioCtx, openModal, closeModal, initUI
        };
    })(); 
    window.ArcadeSettings = ArcadeSettings;

    
    const ArcadeHaptics = (function(){
        function canVibe(){ return !!(navigator && navigator.vibrate); }
        function vibrate(pattern){
            try{ if(canVibe()) navigator.vibrate(pattern); }catch(e){}
        }
        function tap(){ vibrate(18); }
        function success(){ vibrate([18, 30, 40]); }
        function fail(){ vibrate(60); }
        function pop(type, rainbow){
            if(rainbow) return vibrate([12,20,12,20,12]);
            if(type === 'unicorn') return vibrate([18, 22, 18]);
            if(type === 'golden') return vibrate([28, 18, 28]);
            return vibrate(22);
        }
        function milestone(n){
            if(n >= 1000) return vibrate([30,40,30,40,60]);
            if(n % 500 === 0) return vibrate([22, 30, 22, 30, 40]);
            return vibrate(26);
        }
        function open(){ vibrate(22); }
        function back(){ vibrate(18); }

        
        function install(){
            document.addEventListener('pointerdown', (e) => {
                const btn = e.target && e.target.closest ? e.target.closest('button, .ui-btn, .menu-btn') : null;
                if(!btn) return;
                if(btn.disabled) return;
                
                if(btn.closest('canvas')) return;
                tap();
                
                try{ if(window.ArcadeFX) ArcadeFX.init(); }catch(err){}
            }, { passive: true });
        }

        return { tap, success, fail, pop, milestone, open, back, install };
    })();
    window.ArcadeHaptics = ArcadeHaptics;

    const ArcadeFX = (function(){
        let ctx = null;
        function enabled(){ return !(window.ArcadeSettings && !ArcadeSettings.soundOn); }
        function init(){
            try{
                if(!enabled()) return;
                if(!ctx) ctx = new (window.AudioContext||window.webkitAudioContext)();
                if(window.ArcadeSettings) ArcadeSettings.registerAudioCtx(ctx);
                if(ctx.state === 'suspended') ctx.resume();
            }catch(e){}
        }
        function envGain(g, t, a=0.01, d=0.12){
            g.gain.setValueAtTime(0.0001, t);
            g.gain.exponentialRampToValueAtTime(0.25, t+a);
            g.gain.exponentialRampToValueAtTime(0.0001, t+d);
        }
        function ping(freq, t, dur=0.14, type='sine', vol=0.22){
            if(!ctx) return;
            const osc = ctx.createOscillator();
            const g = ctx.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, t);
            g.gain.setValueAtTime(0.0001, t);
            g.gain.exponentialRampToValueAtTime(vol, t+0.01);
            g.gain.exponentialRampToValueAtTime(0.0001, t+dur);
            osc.connect(g); g.connect(ctx.destination);
            osc.start(t);
            osc.stop(t+dur+0.02);
        }
        function chord(freqs, t, dur=0.18, type='sine', vol=0.13){
            freqs.forEach(f => ping(f, t, dur, type, vol));
        }
        function play(name){
            init();
            if(!ctx) return;
            const t = ctx.currentTime + 0.001;

            switch(name){
                case 'success':
                    ping(523.25, t, 0.16, 'sine', 0.24);
                    ping(659.25, t+0.07, 0.16, 'sine', 0.22);
                    ping(783.99, t+0.14, 0.20, 'triangle', 0.20);
                    break;
                case 'fail':
                    ping(220, t, 0.22, 'square', 0.18);
                    ping(164.81, t+0.08, 0.26, 'square', 0.16);
                    break;
                case 'milestone':
                    chord([659.25, 783.99, 987.77], t, 0.20, 'triangle', 0.10);
                    ping(1318.51, t+0.08, 0.14, 'sine', 0.10);
                    break;
                case 'milestoneBig':
                    chord([523.25, 659.25, 783.99], t, 0.22, 'sine', 0.12);
                    chord([659.25, 783.99, 987.77], t+0.14, 0.24, 'triangle', 0.11);
                    break;
                case 'rainbowStart':
                    [880, 1108.73, 1318.51, 1760].forEach((f,i)=> ping(f, t+i*0.05, 0.14, 'sine', 0.12));
                    break;
                case 'rainbowEnd':
                    [1760, 1318.51, 1108.73, 880].forEach((f,i)=> ping(f, t+i*0.05, 0.14, 'triangle', 0.11));
                    break;
                case 'mega':
                    chord([392, 523.25, 659.25], t, 0.24, 'sine', 0.12);
                    chord([523.25, 659.25, 783.99], t+0.18, 0.26, 'triangle', 0.11);
                    ping(1046.5, t+0.32, 0.30, 'sine', 0.12);
                    break;

                case 'slice':
                    
                    ping(1046.5, t, 0.06, 'triangle', 0.10);
                    ping(1318.51, t+0.02, 0.07, 'sine', 0.09);
                    break;
                case 'boom':
                    ping(146.83, t, 0.22, 'square', 0.16);
                    ping(110, t+0.06, 0.26, 'square', 0.14);
                    break;
                case 'heal':
                    chord([523.25, 659.25, 783.99], t, 0.18, 'sine', 0.10);
                    ping(1046.5, t+0.10, 0.16, 'triangle', 0.10);
                    break;

                default:
                    break;
            }
        }
        return { init, play };
    })();
    window.ArcadeFX = ArcadeFX;

    try{ ArcadeHaptics.install(); }catch(e){}

    const ArcadeStore = (function(){
        const prefix = "arcade_";
        const k = (key) => prefix + key;

        function getRaw(key){
            try{ return localStorage.getItem(k(key)); }catch(e){ return null; }
        }
        function setRaw(key, val){
            try{ localStorage.setItem(k(key), val); }catch(e){}
        }

        function getNum(key, def=0){
            const raw = getRaw(key);
            const n = raw == null ? NaN : Number(raw);
            return Number.isFinite(n) ? n : def;
        }
        function setNum(key, num){
            const n = Number(num);
            if(!Number.isFinite(n)) return;
            setRaw(key, String(n));
        }

        function getStr(key, def=""){
            const raw = getRaw(key);
            return raw == null ? def : String(raw);
        }
        function setStr(key, val){
            setRaw(key, String(val));
        }

        function getJSON(key, def=null){
            const raw = getRaw(key);
            if(!raw) return def;
            try{ return JSON.parse(raw); }catch(e){ return def; }
        }
        function setJSON(key, obj){
            try{ setRaw(key, JSON.stringify(obj)); }catch(e){}
        }

        function del(key){
            try{ localStorage.removeItem(k(key)); }catch(e){}
        }

        return { getNum, setNum, getStr, setStr, getJSON, setJSON, del };
    })();
    window.ArcadeStore = ArcadeStore;

    let currentGameId = null;
    ArcadeSettings.initUI();

    
    function openGame(_id) {  }
    function goToMenu() { try{ ArcadeSettings.closeModal(); }catch(e){} window.location.href = 'index.html'; }

const FeedbackSys = (function(){
        const overlay = document.getElementById('feedback-overlay');
        const text = document.getElementById('feedback-content');
        const canvas = document.getElementById('feedback-confetti');
        const ctx = canvas.getContext('2d');
        let particles = [];
        let animId = null;
        let active = false;

        function show(isWin) {
            
            if(show._t) { clearTimeout(show._t); show._t = null; }
            if(animId) { cancelAnimationFrame(animId); animId = null; }
            active = true;

            overlay.style.display = 'flex';
        try{ if(typeof syncDifficultyUI === 'function') syncDifficultyUI(); }catch(e){}
            text.className = isWin ? 'fb-win' : 'fb-loss';
            text.textContent = isWin ? "AWESOME!" : "";
            try{ if(window.ArcadeFX) ArcadeFX.play(isWin ? 'success' : 'fail'); }catch(e){}
            try{ if(window.ArcadeHaptics) { if(isWin) ArcadeHaptics.success(); else ArcadeHaptics.fail(); } }catch(e){}
            particles = [];

            if(isWin && !(window.ArcadeSettings && ArcadeSettings.reduceMotion)) {
                spawnConfetti();
                loop();
            } else {
                ctx.clearRect(0,0,canvas.width,canvas.height);
            }

            show._t = setTimeout(() => {
                overlay.style.display = 'none';
                if(animId) cancelAnimationFrame(animId);
                animId = null;
                active = false;
                show._t = null;
            }, 1500);
        }

        function spawnConfetti() {
            canvas.width = overlay.clientWidth; canvas.height = overlay.clientHeight;
            for(let i=0; i<100; i++) {
                particles.push({
                    x: canvas.width/2, y: canvas.height/2,
                    vx: (Math.random()-0.5)*20, vy: (Math.random()-0.5)*20,
                    c: ['#f00','#0f0','#00f','#ff0','#0ff','#f0f'][Math.floor(Math.random()*6)],
                    size: Math.random()*8+4
                });
            }
        }

        function loop() {
            ctx.clearRect(0,0,canvas.width,canvas.height);
            particles.forEach(p => {
                p.x+=p.vx; p.y+=p.vy; p.vy+=0.5;
                ctx.fillStyle=p.c; ctx.fillRect(p.x,p.y,p.size,p.size);
            });
            animId = requestAnimationFrame(loop);
        }

        return { show };
    })();

    const MiniGolf = (function(){
        const W = 1000, H = 600;
        const PAD = 35; 
        const BALL_R = 11;
        const COLL_R = Math.max(6, BALL_R - 2); 

        const BASE_DECAY = 0.985; 
        const SAND_DECAY = 0.970; 
        const REST = 0.82;        

        let canvas, ctx, wrap, powerFill, stickEl, stickKnob, powerSlider;
        let holeEl, parEl, strokesEl, totalEl;
        let menuOv, holeOv, roundOv, holeSub, roundSub, floatMsg;
        let bestTotal = (window.ArcadeStore ? ArcadeStore.getNum('minigolf_best_total', 0) : 0);
        let bestTotalEl = null;

        let raf = null;
        let loopGen = 0;
        let lastT = 0;
        let active = false;

        let dpr = 1, scalePx = 1, offPxX = 0, offPxY = 0;

        let stickDragging = false;
        let stickCX = 0, stickCY = 0, stickRad = 0;

        let started = false;
        let holeIndex = 0;
        let feedbackShown = false;
        let strokesThis = 0;
        let totalStrokes = 0;
        let holeStrokes = Array(18).fill(0);

        let aim = { on:false, sx:0, sy:0, cx:0, cy:0, power:0, dx:1, dy:0 };
        let sink = { mode:'none', t:0, ang:0, angVel:0, orbR:0, orbitDur:0.65, dropDur:0.33, spinDir:1 };
        let previewDifficulty = 'easy';
        let diffBtns = null;
        let previewKey = '';
        let previewPts = null;

        function readStoredDifficulty(){
            try{
                const v = localStorage.getItem('minigolf_aim_difficulty');
                if(v === 'easy' || v === 'medium' || v === 'hard') return v;
            }catch(e){}
            return 'easy';
        }
        function storeDifficulty(v){
            try{ localStorage.setItem('minigolf_aim_difficulty', v); }catch(e){}
        }
        function updateDiffUI(){
            if(!diffBtns) return;
            for(const k of ['easy','medium','hard']){
                const el = diffBtns[k];
                if(!el) continue;
                el.classList.toggle('active', k === previewDifficulty);
            }
            previewKey = '';
        }



	        
	        let gameTime = 0;
	        let chomp = { active:false, t:0, dur:0.0, x:0, y:0, spin:0, ang0:0, inAng:0, inSpd:0 };

        const ball = { x: 0, y: 0, vx: 0, vy: 0, r: BALL_R };
        let holes = [];
        let holeOrder = Array.from({length:18}, (_,i)=>i);
        let cur = null; 

        const clamp = (v, a, b) => Math.max(a, Math.min(b, v));

        function shuffle(arr){
            for(let i=arr.length-1;i>0;i--){
                const j = (Math.random()*(i+1))|0;
                const t = arr[i]; arr[i]=arr[j]; arr[j]=t;
            }
            return arr;
        }
        const len2 = (x,y) => x*x + y*y;
        const len = (x,y) => Math.hypot(x,y);
        const easeOutCubic = (p) => 1 - Math.pow(1 - p, 3);
        const easeInCubic = (p) => p * p * p;
        const easeInOutCubic = (p) => (p < 0.5) ? (4 * p * p * p) : (1 - Math.pow(-2 * p + 2, 3) / 2);

        function rect(x,y,w,h){ return {type:'rect', x,y,w,h}; }
        function circle(x,y,r){ return {type:'circle', x,y,r}; }
	        function unicorn(x,y,r=26){ return {type:'circle', x,y,r, kind:'unicorn', _lastChomp:-999}; }
        function seg(x1,y1,x2,y2,t=18){ return {type:'seg', x1,y1,x2,y2,t}; }

        function sand(x,y,w,h){ return {type:'sand', x,y,w,h}; }
        function water(x,y,w,h){ return {type:'water', x,y,w,h}; }
        function rotor(x,y,L,T,speed,ang=0){ return {type:'rotor', x,y,L,T, speed, ang}; }

        

        
        function pointBlocked(hole, x, y){
            const r = BALL_R + 2;
            if(x < PAD + r || x > W - PAD - r || y < PAD + r || y > H - PAD - r) return true;
            
            for(const b of (hole.blocks||[])){
                if(b && b.type==='rect'){
                    if(x > b.x - r && x < b.x + b.w + r && y > b.y - r && y < b.y + b.h + r) return true;
                }
            }
            
            for(const w of (hole.waters||[])){
                if(w && w.type==='water'){
                    if(x > w.x - r && x < w.x + w.w + r && y > w.y - r && y < w.y + w.h + r) return true;
                }
            }
            return false;
        }

        function reachable(hole){
            const step = 12;
            const sx = hole.start.x, sy = hole.start.y;
            const gx = hole.cup.x, gy = hole.cup.y;
            const minX = PAD + BALL_R, maxX = W - PAD - BALL_R;
            const minY = PAD + BALL_R, maxY = H - PAD - BALL_R;
            const cols = Math.floor((maxX - minX)/step) + 1;
            const rows = Math.floor((maxY - minY)/step) + 1;
            const toCell = (x,y)=>{
                const cx = Math.round((x - minX)/step);
                const cy = Math.round((y - minY)/step);
                return [cx,cy];
            };
            const [csx,csy] = toCell(sx,sy);
            const [cgx,cgy] = toCell(gx,gy);
            const key = (cx,cy)=> cy*cols + cx;
            const q = [[csx,csy]];
            const seen = new Set([key(csx,csy)]);

            function cellCenter(cx,cy){
                return [minX + cx*step, minY + cy*step];
            }

            while(q.length){
                const [cx,cy] = q.shift();
                if(Math.abs(cx-cgx)+Math.abs(cy-cgy) <= 2) return true;
                const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
                for(const [dx,dy] of dirs){
                    const nx=cx+dx, ny=cy+dy;
                    if(nx<0||ny<0||nx>=cols||ny>=rows) continue;
                    const k = key(nx,ny);
                    if(seen.has(k)) continue;
                    const [px,py] = cellCenter(nx,ny);
                    if(pointBlocked(hole, px, py)) continue;
                    seen.add(k);
                    q.push([nx,ny]);
                }
            }
            return false;
        }

        function carveGapInRect(rect, gapCenter, gapSize){
            
            const pieces = [];
            const vertical = rect.h > rect.w;
            if(vertical){
                const y0 = rect.y;
                const y1 = rect.y + rect.h;
                const g0 = gapCenter - gapSize/2;
                const g1 = gapCenter + gapSize/2;
                const topH = Math.max(0, g0 - y0);
                const botH = Math.max(0, y1 - g1);
                if(topH > 10) pieces.push({type:'rect', x:rect.x, y:y0, w:rect.w, h:topH});
                if(botH > 10) pieces.push({type:'rect', x:rect.x, y:g1, w:rect.w, h:botH});
            }else{
                const x0 = rect.x;
                const x1 = rect.x + rect.w;
                const g0 = gapCenter - gapSize/2;
                const g1 = gapCenter + gapSize/2;
                const leftW = Math.max(0, g0 - x0);
                const rightW = Math.max(0, x1 - g1);
                if(leftW > 10) pieces.push({type:'rect', x:x0, y:rect.y, w:leftW, h:rect.h});
                if(rightW > 10) pieces.push({type:'rect', x:g1, y:rect.y, w:rightW, h:rect.h});
            }
            return pieces;
        }

        function ensureReachable(hole){
            if(reachable(hole)) return;
            
            const gap = BALL_R * 3.2;
            const sx = hole.start.x, sy = hole.start.y;
            const gx = hole.cup.x, gy = hole.cup.y;
            const blocks = hole.blocks || [];
            const newBlocks = [];
            let carved = 0;

            function lineYAtX(x){
                const t = (x - sx) / (gx - sx || 1e-9);
                return sy + (gy - sy) * t;
            }
            function lineXAtY(y){
                const t = (y - sy) / (gy - sy || 1e-9);
                return sx + (gx - sx) * t;
            }

            for(const b of blocks){
                if(!(b && b.type==='rect')){ newBlocks.push(b); continue; }
                if(carved >= 3){ newBlocks.push(b); continue; }
                const vertical = b.h > b.w;
                if(vertical){
                    const xMid = b.x + b.w/2;
                    
                    const yOnLine = lineYAtX(xMid);
                    if(yOnLine > b.y - gap && yOnLine < b.y + b.h + gap){
                        newBlocks.push(...carveGapInRect(b, yOnLine, gap));
                        carved++;
                        continue;
                    }
                }else{
                    const yMid = b.y + b.h/2;
                    const xOnLine = lineXAtY(yMid);
                    if(xOnLine > b.x - gap && xOnLine < b.x + b.w + gap){
                        newBlocks.push(...carveGapInRect(b, xOnLine, gap));
                        carved++;
                        continue;
                    }
                }
                newBlocks.push(b);
            }
            hole.blocks = newBlocks;

            
            if(!reachable(hole)){
                const corridor = BALL_R * 3.6;
                hole.blocks = (hole.blocks||[]).filter(b => {
                    if(!(b && b.type==='rect')) return true;
                    
                    const cx = (sx + gx)/2;
                    const cy = (sy + gy)/2;
                    const rx = b.x + b.w/2;
                    const ry = b.y + b.h/2;
                    const dx = rx - cx, dy = ry - cy;
                    return (dx*dx + dy*dy) > (corridor*corridor);
                });
            }
        }

        function buildHoles(){
            holes = [
                { par: 3, start:{x:PAD+80, y:H/2}, cup:{x:W-PAD-80, y:H/2, r:16},
                  blocks:[
                      rect(W/2-20, PAD+90, 40, H-2*(PAD+90))
                  ],
                  bumpers:[], sands:[], waters:[], rotors:[]
                },
	                { par: 3, start:{x:PAD+90, y:PAD+90}, cup:{x:W-PAD-90, y:H-PAD-90, r:16},
	                  
	                  blocks:[],
	                  
	                  bumpers:[
	                      unicorn(W/2, H/2-30, 26),
	                      circle(W/2-60, H/2+55, 18),
	                      circle(W/2+60, H/2+55, 18)
	                  ],
	                  sands:[
	                      sand(W-PAD-350, H/2+120, 220, 130)
	                  ],
	                  waters:[
	                      water(PAD+125, H/2-85, 260, 170),
	                      water(W-PAD-385, H/2-85, 260, 170)
	                  ],
	                  rotors:[
	                      rotor(W/2, H/2+10, 240, 18, 1.6, 0.4)
	                  ]
	                },
                { par: 4, start:{x:PAD+80, y:H-PAD-90}, cup:{x:W-PAD-80, y:PAD+90, r:16},
                  blocks:[
                      rect(PAD+180, PAD+120, W-PAD*2-360, 18),
                      rect(PAD+180, H-PAD-138, W-PAD*2-360, 18),
                      rect(PAD+180, PAD+120, 18, H-PAD*2-258),
                      rect(W-PAD-198, PAD+258, 18, H-PAD*2-378),
                  ],
                  bumpers:[], sands:[], waters:[], rotors:[]
                },
                { par: 3, start:{x:PAD+80, y:H/2}, cup:{x:W-PAD-90, y:H/2, r:16},
                  blocks:[
                      rect(W/2-9, PAD+60, 18, H-PAD*2-120),
                      rect(W/2+140, PAD+120, 18, H-PAD*2-240),
                  ],
                  bumpers:[],
                  sands:[sand(W/2-140, H/2-90, 280, 180)],
                  waters:[], rotors:[]
                },
                { par: 4, start:{x:PAD+90, y:H/2}, cup:{x:W-PAD-90, y:PAD+110, r:16},
                  blocks:[
                      rect(PAD+260, PAD+90, 18, H-PAD*2-180),
                      rect(PAD+260, PAD+90, W-PAD*2-520, 18),
                      rect(W-PAD-260, PAD+90, 18, H-PAD*2-180),
                  ],
                  bumpers:[circle(W/2, H/2, 20)],
                  sands:[],
                  waters:[water(W/2-130, H/2-80, 260, 160)],
                  rotors:[]
                },
                { par: 3, start:{x:PAD+90, y:H/2}, cup:{x:W-PAD-100, y:H/2, r:16},
                  blocks:[
                      rect(W/2-10, PAD+60, 20, H-PAD*2-120),
                  ],
                  bumpers:[circle(W/2+170, H/2-100, 20), circle(W/2+210, H/2, 22), circle(W/2+170, H/2+100, 20)],
                  sands:[], waters:[], rotors:[]
                },
                { par: 4, start:{x:PAD+90, y:H-PAD-90}, cup:{x:W-PAD-90, y:PAD+90, r:16},
                  blocks:[
                      rect(PAD+220, PAD+120, 18, H-PAD*2-240),
                      rect(W-PAD-238, PAD+120, 18, H-PAD*2-240),
                      rect(PAD+220, H/2-40, W-PAD*2-440, 18),
                      rect(PAD+220, H/2+22, W-PAD*2-440, 18),
                  ],
                  bumpers:[],
                  sands:[],
                  waters:[water(PAD+240, PAD+140, W-PAD*2-480, H-PAD*2-280)],
                  rotors:[]
                },
                { par: 4, start:{x:PAD+90, y:H/2}, cup:{x:W-PAD-90, y:H/2, r:16},
                  blocks:[
                      rect(W/2-10, PAD+60, 20, H-PAD*2-120),
                  ],
                  bumpers:[
                      
                      circle(W/2+80, H/2-140, 18), circle(W/2+105, H/2-165, 14),
                      circle(W/2+80, H/2+140, 18), circle(W/2+105, H/2+165, 14),
                      circle(W/2+260, H/2, 16)
                  ],
                  sands:[],
                  waters:[],
                  rotors:[
                      
                      rotor(W/2+180, H/2, 240, 18, 2.2, 0),
                      rotor(W/2+180, H/2, 240, 18, 2.2, Math.PI/2)
                  ]
                },
                { par: 3, start:{x:PAD+90, y:PAD+90}, cup:{x:W-PAD-90, y:H-PAD-90, r:16},
                  blocks:[
                      rect(W/2-160, H/2-140, 18, 280),
                      rect(W/2-40,  H/2-200, 18, 400),
                      rect(W/2+80,  H/2-140, 18, 280),
                  ],
                  bumpers:[circle(W/2+220, H/2-120, 18)],
                  sands:[], waters:[], rotors:[]
                },
                { par: 4, start:{x:PAD+90, y:H/2}, cup:{x:W-PAD-90, y:H/2, r:16},
                  blocks:[
                      rect(PAD+250, PAD+70, 18, H-PAD*2-140),
                      rect(PAD+250, PAD+70, W/2-PAD-250, 18),
                      rect(PAD+250, H-PAD-88, W/2-PAD-250, 18),

                      rect(W/2+110, PAD+70, 18, H-PAD*2-140),
                      rect(W/2+110, PAD+70, W-PAD*2-(W/2+110), 18),
                      rect(W/2+110, H-PAD-88, W-PAD*2-(W/2+110), 18),
                  ],
                  bumpers:[circle(W/2+55, H/2, 18)],
                  sands:[sand(W/2+170, H/2-80, 200, 160)],
                  waters:[], rotors:[]
                },
                { par: 4, start:{x:PAD+90, y:H-PAD-90}, cup:{x:W-PAD-90, y:PAD+90, r:16},
                  blocks:[
                      rect(PAD+200, PAD+120, W-PAD*2-400, 18),
                      rect(PAD+200, H-PAD-138, W-PAD*2-400, 18),
                      rect(PAD+200, PAD+120, 18, H/2-PAD-120),
                      rect(W-PAD-218, H/2+30, 18, H/2-PAD-168),
                  ],
                  bumpers:[],
                  sands:[],
                  waters:[water(W/2-120, H/2-70, 240, 140)],
                  rotors:[]
                },
                { par: 3, start:{x:PAD+90, y:H/2}, cup:{x:W-PAD-90, y:H/2, r:16},
                  blocks:[],
                  bumpers:[
                      circle(W/2, H/2, 60),
                      circle(W/2-120, H/2, 20),
                      circle(W/2+120, H/2, 20),
                  ],
                  sands:[], waters:[], rotors:[]
                },
                { par: 2, start:{x:PAD+90, y:H/2}, cup:{x:W-PAD-90, y:H/2, r:14},
                  blocks:[
                      rect(W/2-10, PAD+60, 20, H-PAD*2-120),
                      rect(W-PAD-220, PAD+120, 18, H-PAD*2-240),
                      rect(W-PAD-220, PAD+120, 140, 18),
                      rect(W-PAD-220, H-PAD-138, 140, 18),
                  ],
                  bumpers:[], sands:[sand(W-PAD-360, H/2-70, 160, 140)], waters:[], rotors:[]
                },
                { par: 5, start:{x:PAD+90, y:H/2}, cup:{x:W-PAD-90, y:H/2, r:16},
                  blocks:[
                      rect(W/2-10, PAD+60, 20, H-PAD*2-120),
                  ],
                  bumpers:[
                      
                      circle(W/2+40, H/2, 20), circle(W/2+65, H/2+25, 14), circle(W/2+65, H/2-25, 14)
                  ],
                  sands:[],
                  waters:[],
                  rotors:[
                      rotor(W/2+150, H/2-120, 240, 18, 1.8, 0.3),
                      rotor(W/2+150, H/2+120, 240, 18, -1.6, -0.2),
                      
                      rotor(W/2+260, H/2, 170, 16, 2.7, 0),
                      rotor(W/2+260, H/2, 170, 16, 2.7, Math.PI/2)
                  ]
                },
                { par: 5, start:{x:PAD+90, y:PAD+90}, cup:{x:W-PAD-90, y:H-PAD-90, r:16},
                  blocks:[
                      rect(PAD+200, PAD+120, 18, H-PAD*2-240),
                      rect(PAD+200, PAD+120, W-PAD*2-400, 18),
                      rect(W-PAD-218, PAD+240, 18, H-PAD*2-360),
                      rect(PAD+320, H-PAD-138, W-PAD*2-520, 18),
                      rect(PAD+320, PAD+240, 18, H-PAD*2-378),
                  ],
                  bumpers:[circle(W/2+50, H/2-60, 18), circle(W/2-90, H/2+80, 20)],
                  sands:[sand(PAD+240, H/2-60, 160, 120)],
                  waters:[water(W/2-180, H/2-110, 360, 220)],
                  rotors:[]
                },
                { par: 4, start:{x:PAD+90, y:H/2}, cup:{x:W-PAD-90, y:H/2, r:16},
                  blocks:[
                      rect(PAD+260, PAD+90, 18, H-PAD*2-180),
                      rect(W-PAD-278, PAD+90, 18, H-PAD*2-180),
                  ],
                  bumpers:[
                      circle(W/2, H/2-160, 20),
                      circle(W/2-90, H/2-40, 18),
                      circle(W/2+90, H/2+40, 18),
                      circle(W/2, H/2+160, 20),
                  ],
                  sands:[sand(W/2-120, H/2-60, 240, 120)],
                  waters:[],
                  rotors:[]
                },
                { par: 5, start:{x:PAD+90, y:H-PAD-90}, cup:{x:W-PAD-90, y:PAD+90, r:16},
                  blocks:[
                      rect(PAD+220, PAD+120, W-PAD*2-440, 18),
                      rect(PAD+220, H-PAD-138, W-PAD*2-440, 18),
                      rect(PAD+220, PAD+120, 18, H/2-PAD-120),
                      rect(W-PAD-238, H/2+30, 18, H/2-PAD-168),
                      rect(PAD+350, H/2-40, W-PAD*2-700, 18),
                      rect(PAD+350, H/2+22, W-PAD*2-700, 18),
                  ],
                  bumpers:[circle(W/2+180, H/2, 20)],
                  sands:[],
                  waters:[water(W/2-120, H/2-80, 240, 160)],
                  rotors:[]
                },
                { par: 6, start:{x:PAD+90, y:H/2}, cup:{x:W-PAD-90, y:H/2, r:16},
                  blocks:[
                      rect(W/2-10, PAD+60, 20, H-PAD*2-120),
                      rect(PAD+260, PAD+110, 18, H-PAD*2-220),
                      rect(W-PAD-278, PAD+110, 18, H-PAD*2-220),
                      rect(PAD+260, PAD+110, 180, 18),
                      rect(W-PAD-440, H-PAD-128, 180, 18),
                  ],
                  bumpers:[circle(W/2+200, H/2-160, 20), circle(W/2+200, H/2+160, 20)],
                  sands:[sand(W/2-160, H/2-90, 320, 180)],
                  waters:[water(W/2-120, H/2-55, 240, 110)],
                  rotors:[rotor(W/2+190, H/2, 260, 18, 2.0, 0.1)]
                },
            ];

            try{ holes.forEach(h => ensureReachable(h)); }catch(e){}
            
            const pickNearPath = (h, tMin=0.30, tMax=0.78, spread=110) => {
                const sx = h.start.x, sy = h.start.y;
                const ex = h.cup.x, ey = h.cup.y;
                const vx = ex - sx, vy = ey - sy;
                const L = Math.hypot(vx, vy) || 1;
                const ux = vx / L, uy = vy / L;
                const px = -uy, py = ux;

                const t = tMin + Math.random()*(tMax - tMin);
                const along = (Math.random()*2-1) * 42;
                const off = (Math.random()*2-1) * spread;

                let x = sx + vx*t + ux*along + px*off;
                let y = sy + vy*t + uy*along + py*off;
                x = clamp(x, PAD+120, W-PAD-120);
                y = clamp(y, PAD+120, H-PAD-120);
                return {x,y};
            };
            const farFromStartCup = (h, x, y, min=120) => (
                Math.hypot(x - h.start.x, y - h.start.y) > min &&
                Math.hypot(x - h.cup.x,  y - h.cup.y ) > min
            );
            const inAnyBlock = (h, x, y, m=26) => {
                const bs = h.blocks || [];
                for(const b of bs){
                    if(x > (b.x - m) && x < (b.x + b.w + m) && y > (b.y - m) && y < (b.y + b.h + m)) return true;
                }
                return false;
            };

            for(let i=0;i<holes.length;i++){
                const h = holes[i];
                
                const jx = (Math.random()*2-1) * 24;
                const jy = (Math.random()*2-1) * 18;
                h.cup.x = clamp(h.cup.x + jx, PAD+90, W-PAD-90);
                h.cup.y = clamp(h.cup.y + jy, PAD+90, H-PAD-90);

                
                if(Math.random() < 0.55){
                    h.bumpers = h.bumpers || [];
                    let p = pickNearPath(h, 0.22, 0.82, 125);
                    for(let tries=0; tries<9 && (!farFromStartCup(h, p.x, p.y, 135) || inAnyBlock(h, p.x, p.y, 36)); tries++){
                        p = pickNearPath(h, 0.22, 0.82, 125);
                    }
                    const tx = p.x, ty = p.y;
                    h.bumpers.push({type:'circle', x:tx, y:ty, r: (Math.random()<0.5?18:24), kind:'tree'});
                }

                
                if(Math.random() < 0.45){
                    h.bumpers = h.bumpers || [];
                    const inset = PAD + 18 + (Math.random()*22);
                    const L = 140 + (Math.random()*80);
                    
                    h.bumpers.push(seg(inset, inset, inset+L, inset+L, 20));
                    
                    h.bumpers.push(seg(W-inset, H-inset, W-inset-L, H-inset-L, 20));
                }

                
                if(Math.random() < 0.6){
                    h.rotors = h.rotors || [];
                    let p = pickNearPath(h, 0.32, 0.78, 95);
                    for(let tries=0; tries<9 && (!farFromStartCup(h, p.x, p.y, 160) || inAnyBlock(h, p.x, p.y, 44)); tries++){
                        p = pickNearPath(h, 0.32, 0.78, 95);
                    }
                    const rx = p.x, ry = p.y;
                    const blade = 170 + Math.random()*120;
                    const thick = 16 + Math.random()*10;
                    const speed = (Math.random()<0.5?-1:1) * (0.9 + Math.random()*1.1);
                    h.rotors.push(rotor(rx, ry, blade, thick, speed, Math.random()*Math.PI*2));
                }

                
                if(Math.random() < 0.35){
                    h.rotors = h.rotors || [];
                    const rx = clamp(h.cup.x + (Math.random()*2-1)*120, PAD+120, W-PAD-120);
                    const ry = clamp(h.cup.y + (Math.random()*2-1)*90, PAD+120, H-PAD-120);
                    const blade = 120 + Math.random()*60;
                    const thick = 14 + Math.random()*8;
                    const speed = (Math.random()<0.5?-1:1) * (1.2 + Math.random()*1.2);
                    h.rotors.push(rotor(rx, ry, blade, thick, speed, Math.random()*Math.PI*2));
                }
            }

        }

        
        function updateStickMetrics(){
            if(!stickEl) return;
            const r = stickEl.getBoundingClientRect();
            stickCX = r.left + r.width/2;
            stickCY = r.top + r.height/2;
            stickRad = Math.max(10, Math.min(r.width, r.height)/2 - 18);
        }

        function updateStickUI(){
            if(!stickKnob || !stickEl) return;
            updateStickMetrics();
            const x = aim.dx * stickRad;
            const y = aim.dy * stickRad;
            stickKnob.style.left = `calc(50% + ${x.toFixed(1)}px)`;
            stickKnob.style.top  = `calc(50% + ${y.toFixed(1)}px)`;
        }

        function setAimDir(dx, dy){
            const d = Math.hypot(dx, dy);
            if(d < 10) return;

            const nx = dx / d, ny = dy / d;

            const curAng = Math.atan2(aim.dy, aim.dx);
            const tgtAng = Math.atan2(ny, nx);
            let delta = tgtAng - curAng;

            delta = (delta + Math.PI*3) % (Math.PI*2) - Math.PI;

            const TURN_SCALE = 0.25;
            delta *= TURN_SCALE;

            const maxStep = 0.035;
            delta = clamp(delta, -maxStep, maxStep);

            const a = curAng + delta;
            aim.dx = Math.cos(a);
            aim.dy = Math.sin(a);
            updateStickUI();
        }

                function setPowerRaw(raw){
            const r = clamp(raw, 0, 1);
            aim.power = r*r;
            updatePower(aim.power);
        }

        function initDom(){
            canvas = document.getElementById('mg-canvas');
            ctx = canvas.getContext('2d');
            wrap = document.querySelector('#g-minigolf .mg-canvas-wrap');
            powerFill = document.getElementById('mg-power');
            powerSlider = document.getElementById('mg-power-slider');
            stickEl = document.getElementById('mg-stick');
            stickKnob = document.getElementById('mg-stick-knob');

            holeEl = document.getElementById('mg-hole');
            parEl = document.getElementById('mg-par');
            strokesEl = document.getElementById('mg-strokes');
            totalEl = document.getElementById('mg-total');

            menuOv = document.getElementById('mg-menu');
            holeOv = document.getElementById('mg-hole-overlay');
            roundOv = document.getElementById('mg-round-overlay');
            holeSub = document.getElementById('mg-hole-sub');
            roundSub = document.getElementById('mg-round-sub');
            floatMsg = document.getElementById('mg-float-msg');
            bestTotalEl = document.getElementById('mg-best-total');
            if(bestTotalEl) bestTotalEl.textContent = bestTotal ? String(bestTotal) : '';

            previewDifficulty = readStoredDifficulty();
            diffBtns = {
                easy: document.getElementById('mg-diff-easy'),
                medium: document.getElementById('mg-diff-medium'),
                hard: document.getElementById('mg-diff-hard'),
            };
            updateDiffUI();


            if(powerSlider){
                powerSlider.addEventListener('input', () => {
                    const raw = clamp(parseFloat(powerSlider.value || '0') / 100, 0, 1);
                    setPowerRaw(raw);
                });
                const raw0 = clamp(parseFloat(powerSlider.value || '0') / 100, 0, 1);
                setPowerRaw(raw0);
            } else {
                setPowerRaw(0.35);
            }

            const stickDown = (e) => {
                if(!active) return;
                if(menuOv.style.display !== 'none') return;
                if(holeOv.style.display !== 'none') return;
                if(roundOv.style.display !== 'none') return;
                stickDragging = true;
                updateStickMetrics();
                setAimDir(e.clientX - stickCX, e.clientY - stickCY);
                stickEl.setPointerCapture?.(e.pointerId);
                e.preventDefault();
            };
            const stickMove = (e) => {
                if(!stickDragging) return;
                setAimDir(e.clientX - stickCX, e.clientY - stickCY);
                e.preventDefault();
            };
            const stickUp = (e) => {
                stickDragging = false;
                e.preventDefault?.();
            };

            if(stickEl){
                stickEl.addEventListener('pointerdown', stickDown, {passive:false});
                stickEl.addEventListener('pointermove', stickMove, {passive:false});
                stickEl.addEventListener('pointerup', stickUp, {passive:false});
                stickEl.addEventListener('pointercancel', stickUp, {passive:false});
            }

            const onCanvasDown = (e) => {
                if(!active) return;
                if(menuOv.style.display !== 'none') return;
                if(holeOv.style.display !== 'none') return;
                if(roundOv.style.display !== 'none') return;

                if(isBallMoving()) return;
                if(sink.mode !== 'none') return;

                const p = toWorld(e.clientX, e.clientY);
                const dx = p.x - ball.x;
                const dy = p.y - ball.y;
                if(Math.hypot(dx, dy) > 8){
                    setAimDir(dx, dy);
                }
                e.preventDefault();
            };

            canvas.addEventListener('pointerdown', onCanvasDown, {passive:false});

            updateStickUI();
        }

        function shoot(){
            if(!active) return;
            if(menuOv.style.display !== 'none') return;
            if(holeOv.style.display !== 'none') return;
            if(roundOv.style.display !== 'none') return;
            if(isBallMoving()) return;
            if(sink.mode !== 'none') return;

            const pwr = clamp(aim.power || 0, 0, 1);
            if(pwr <= 0.001){
                showMsg("Set some power!", 800);
                return;
            }

            const speed = 150 + 1710 * pwr;
            ball.vx = (aim.dx || 1) * speed;
            ball.vy = (aim.dy || 0) * speed;

            addStroke(1);
        }

        function isBallMoving(){
            return (Math.hypot(ball.vx, ball.vy) > 12);
        }

        function addStroke(n){
            strokesThis += n;
            totalStrokes += n;
            holeStrokes[holeIndex] = strokesThis;
            updateUI();
        }

        function totalPar(){
            return holes.reduce((s,h) => s + (h.par||0), 0);
        }

        function updateUI(){
            holeEl.textContent = String(holeIndex + 1);
            parEl.textContent = String(cur?.par ?? 3);
            strokesEl.textContent = String(strokesThis);
            totalEl.textContent = String(totalStrokes);
        }

        function showMsg(txt, ms=900){
            if(!floatMsg) return;
            floatMsg.textContent = txt;
            floatMsg.style.display = 'block';
            clearTimeout(showMsg._t);
            showMsg._t = setTimeout(() => { floatMsg.style.display = 'none'; }, ms);
        }

	        function startChomp(u){
	            if(!u) return false;
	            if(chomp.active) return false;
	            const spd = Math.hypot(ball.vx, ball.vy);
	            if(spd < 35) return false;
	            if((gameTime - (u._lastChomp || -999)) < 1.2) return false;
	            u._lastChomp = gameTime;

	            chomp.active = true;
	            chomp.t = 0;
	            chomp.dur = 0.55 + Math.random()*0.35;
	            chomp.x = u.x;
	            chomp.y = u.y;
	            chomp.spin = (Math.random() < 0.5 ? -1 : 1) * (7 + Math.random()*7);
	            chomp.ang0 = Math.atan2(ball.y - u.y, ball.x - u.x);
	            chomp.inAng = Math.atan2(ball.vy, ball.vx);
	            chomp.inSpd = spd;

	            ball.vx = 0;
	            ball.vy = 0;
	            ball.x = u.x;
	            ball.y = u.y;
	            ball.r = BALL_R;

	            showMsg("CHOMP!", 750);
	            return true;
	        }

function distPointToSegment(px, py, ax, ay, bx, by){
    const abx = bx-ax, aby = by-ay;
    const apx = px-ax, apy = py-ay;
    const ab2 = abx*abx + aby*aby;
    let t = ab2 > 0 ? (apx*abx + apy*aby) / ab2 : 0;
    t = Math.max(0, Math.min(1, t));
    const cx = ax + t*abx, cy = ay + t*aby;
    const dx = px-cx, dy = py-cy;
    return Math.hypot(dx, dy);
}

function circleIntersectsRect(cx, cy, cr, rx, ry, rw, rh){
    const nx = Math.max(rx, Math.min(cx, rx+rw));
    const ny = Math.max(ry, Math.min(cy, ry+rh));
    const dx = cx-nx, dy = cy-ny;
    return (dx*dx + dy*dy) <= cr*cr;
}

function pointClearForSpawn(x, y, r, h){
    const M = 2; 
    if(x < PAD + r + M || x > W - PAD - r - M || y < PAD + r + M || y > H - PAD - r - M) return false;

    if(h.blocks){
        for(const b of h.blocks){
            if(circleIntersectsRect(x, y, r+M, b.x, b.y, b.w, b.h)) return false;
        }
    }
    if(h.bumpers){
        for(const c of h.bumpers){
            const dx = x - c.x, dy = y - c.y;
            const rr = (c.r || 0) + r + M;
            if(dx*dx + dy*dy < rr*rr) return false;
        }
    }
    if(h.rotors){
        for(const ro of h.rotors){
            const half = (ro.len || 0) * 0.5;
            const ang = ro.ang || 0;
            const ax = ro.x + Math.cos(ang) * (-half);
            const ay = ro.y + Math.sin(ang) * (-half);
            const bx = ro.x + Math.cos(ang) * (half);
            const by = ro.y + Math.sin(ang) * (half);
            const thick = (ro.thick || 0);
            const d = distPointToSegment(x, y, ax, ay, bx, by);
            if(d <= (thick*0.5 + r + M)) return false;
        }
    }
    return true;
}

function findNearestClear(x0, y0, r, h){
    if(pointClearForSpawn(x0, y0, r, h)) return {x:x0, y:y0};
    const step = Math.max(10, r*1.5);
    for(let ring=1; ring<=18; ring++){
        const rad = ring * step;
        const pts = 12 + ring * 4;
        for(let i=0;i<pts;i++){
            const a = (i/pts) * Math.PI*2;
            const x = x0 + Math.cos(a)*rad;
            const y = y0 + Math.sin(a)*rad;
            if(pointClearForSpawn(x, y, r, h)) return {x, y};
        }
    }
    
    return { x: clamp(x0, PAD+r+4, W-PAD-r-4), y: clamp(y0, PAD+r+4, H-PAD-r-4) };
}



        function loadHole(i){
            holeIndex = clamp(i, 0, 17);
            cur = holes[holeOrder[holeIndex]];

try{
    const sOk = findNearestClear(cur.start.x, cur.start.y, BALL_R, cur);
    cur.start.x = sOk.x; cur.start.y = sOk.y;
    const cupR = (cur.cup && cur.cup.r) ? cur.cup.r : 16;
    const cOk = findNearestClear(cur.cup.x, cur.cup.y, cupR, cur);
    cur.cup.x = cOk.x; cur.cup.y = cOk.y;
}catch(e){}

            strokesThis = holeStrokes[holeIndex] || 0;

            ball.x = cur.start.x; ball.y = cur.start.y;
            ball.vx = 0; ball.vy = 0;
            ball.r = BALL_R;

            
            
            setAimDir(cur.cup.x - ball.x, cur.cup.y - ball.y);
	            sink.mode = 'none'; sink.t = 0;
	            chomp.active = false; chomp.t = 0;
            feedbackShown = false;
            updateUI();

            holeOv.style.display = 'none';
            roundOv.style.display = 'none';
        }

        function updatePower(p){
            powerFill.style.width = (p*100).toFixed(1) + '%';
        }

        function startLoop(){
            loopGen++;
            const myGen = loopGen;
            if(raf) cancelAnimationFrame(raf);
            lastT = performance.now();
            const step = (t) => {
                if(!active || myGen !== loopGen) return;
                const dt = Math.min(0.033, Math.max(0.001, (t - lastT) / 1000));
                lastT = t;

                tick(dt);
                draw();

                raf = requestAnimationFrame(step);
            };
            raf = requestAnimationFrame(step);
        }

        function beginSink(){
            if(!cur) return false;
            if(sink.mode !== 'none') return false;

            const cup = cur.cup;
            const dx = ball.x - cup.x, dy = ball.y - cup.y;
            const d = Math.hypot(dx, dy) || 0.0001;
            const spd = Math.hypot(ball.vx, ball.vy);

            const cross = dx * ball.vy - dy * ball.vx;

            sink.mode = 'orbit';
            sink.t = 0;
            sink.spinDir = (cross >= 0) ? 1 : -1;
            sink.orbR = cup.r + BALL_R * 0.22;
            sink.ang = Math.atan2(dy, dx);
            sink.angVel = clamp(spd / (sink.orbR || 1), 8, 16);
            sink.orbitDur = 0.55 + 0.25 * clamp(spd / 360, 0, 1);
            sink.dropDur = 0.32;

            ball.vx = 0; ball.vy = 0;
            ball.r = BALL_R;
            ball.x = cup.x + Math.cos(sink.ang) * sink.orbR;
            ball.y = cup.y + Math.sin(sink.ang) * sink.orbR;
            return true;
        }

        function tick(dt){
            if(!cur) return false;

	            gameTime += dt;
	            if(chomp.active){
	                chomp.t += dt;
	                const p = clamp(chomp.t / (chomp.dur || 0.0001), 0, 1);
	                const swirlR = 6 + 10 * (1 - p);
	                const a = chomp.ang0 + chomp.spin * chomp.t;
	                ball.x = chomp.x + Math.cos(a) * swirlR;
	                ball.y = chomp.y + Math.sin(a) * swirlR;
	                ball.vx = 0; ball.vy = 0;
	                ball.r = BALL_R * (1 - 0.30 * easeOutCubic(p));

	                if(p >= 1){
	                    ball.r = BALL_R;
	                    chomp.active = false;
	                    const base = chomp.inAng + (Math.random()*2 - 1) * Math.PI * 0.85;
	                    const spd = 280 + Math.random()*320 + chomp.inSpd * 0.40;
	                    ball.x = clamp(chomp.x + Math.cos(base) * (BALL_R + 10), PAD + BALL_R, W - PAD - BALL_R);
	                    ball.y = clamp(chomp.y + Math.sin(base) * (BALL_R + 10), PAD + BALL_R, H - PAD - BALL_R);
	                    ball.vx = Math.cos(base) * spd;
	                    ball.vy = Math.sin(base) * spd;
	                    showMsg("SPIT!", 750);
	                }
	                wallBounds();
	                return;
	            }

            if(cur.rotors && cur.rotors.length){
                for(const r of cur.rotors){
                    r.ang += r.speed * dt;
                }
            }

            if(sink.mode !== 'none'){
                const cup = cur.cup;
                sink.t += dt;

                if(sink.mode === 'orbit'){
                    const p = clamp(sink.t / sink.orbitDur, 0, 1);
                    const slow = 1 - 0.70 * easeOutCubic(p);
                    sink.ang += sink.spinDir * sink.angVel * slow * dt;

                    const R = sink.orbR * (1 - 0.55 * easeInOutCubic(p));
                    ball.x = cup.x + Math.cos(sink.ang) * R;
                    ball.y = cup.y + Math.sin(sink.ang) * R;

                    ball.vx = 0; ball.vy = 0;
                    ball.r = BALL_R * (1 - 0.10 * easeOutCubic(p));

                    if(p >= 1){
                        sink.mode = 'drop';
                        sink.t = 0;
                        ball.x = cup.x; ball.y = cup.y;
                    }
                    return;
                }

                if(sink.mode === 'drop'){
                    const p = clamp(sink.t / sink.dropDur, 0, 1);
                    ball.x = cup.x; ball.y = cup.y;
                    ball.vx = 0; ball.vy = 0;
                    ball.r = BALL_R * (1 - easeInCubic(p));
                    if(p >= 1){
                        ball.r = 0;
                        sink.mode = 'none';
                        onHoleComplete();
                    }
                    return;
                }
            }

            ball.x += ball.vx * dt;
            ball.y += ball.vy * dt;

            let decay = BASE_DECAY;
            if(cur.sands && cur.sands.some(z => pointInRect(ball.x, ball.y, z))) decay = SAND_DECAY;

            const f = Math.pow(decay, dt * 60);
            ball.vx *= f;
            ball.vy *= f;

            if(Math.hypot(ball.vx, ball.vy) < 10){
                ball.vx = 0; ball.vy = 0;
            }

            wallBounds();

            if(cur.blocks) for(const b of cur.blocks) collideRect(b);
            if(cur.bumpers) for(const c of cur.bumpers){ if(c && c.type==='seg') collideSeg(c); else collideCircle(c); }

            if(cur.rotors) for(const r of cur.rotors) collideRotor(r);

            if(cur.waters && cur.waters.some(z => pointInRect(ball.x, ball.y, z))){
                addStroke(1);
                showMsg("SPLASH! +1", 900);
                ball.x = cur.start.x; ball.y = cur.start.y;
                ball.vx = 0; ball.vy = 0;
            }

            const cup = cur.cup;
            const dx = ball.x - cup.x, dy = ball.y - cup.y;
            const d = Math.hypot(dx, dy) || 0.0001;
            const spd = Math.hypot(ball.vx, ball.vy);
            const vr = (ball.vx*dx + ball.vy*dy) / d; 

            const captureZone = cup.r + BALL_R * 0.55;
            const pullZone = cup.r + BALL_R * 1.75;

            if(d < captureZone){
                if(vr < 80 && spd < 520){
                    if(!feedbackShown && beginSink()){
                        feedbackShown = true;
                        FeedbackSys.show(true);
                    }
                } else {
                    const nx = dx / d, ny = dy / d;
                    ball.x = cup.x + nx * captureZone;
                    ball.y = cup.y + ny * captureZone;
                    reflect(nx, ny, 0.72);
                    ball.vx *= 0.92; ball.vy *= 0.92;
                }
            } else if(d < pullZone && spd < 420){
                const nx = -dx / d, ny = -dy / d;
                const strength = clamp((pullZone - d) / (pullZone - captureZone), 0, 1);
                const a = 260 * strength;
                ball.vx += nx * a * dt;
                ball.vy += ny * a * dt;
            }
        }

        function pointInRect(px, py, r){
            return (px >= r.x && px <= r.x + r.w && py >= r.y && py <= r.y + r.h);
        }

        function wallBounds(){
            const minX = PAD + BALL_R, maxX = W - PAD - BALL_R;
            const minY = PAD + BALL_R, maxY = H - PAD - BALL_R;

            if(ball.x < minX){ ball.x = minX; ball.vx = Math.abs(ball.vx) * REST; }
            if(ball.x > maxX){ ball.x = maxX; ball.vx = -Math.abs(ball.vx) * REST; }
            if(ball.y < minY){ ball.y = minY; ball.vy = Math.abs(ball.vy) * REST; }
            if(ball.y > maxY){ ball.y = maxY; ball.vy = -Math.abs(ball.vy) * REST; }
        }

        function collideRect(r){
            const cx = clamp(ball.x, r.x, r.x + r.w);
            const cy = clamp(ball.y, r.y, r.y + r.h);
            let dx = ball.x - cx;
            let dy = ball.y - cy;
            const dist = Math.hypot(dx, dy);

            if(dist > 0 && dist < COLL_R){
                const nx = dx / dist;
                const ny = dy / dist;
                const push = (COLL_R - dist) + 0.2;
                ball.x += nx * push;
                ball.y += ny * push;

                reflect(nx, ny);
            } else if(dist === 0){
                const left = Math.abs(ball.x - r.x);
                const right = Math.abs(r.x + r.w - ball.x);
                const top = Math.abs(ball.y - r.y);
                const bottom = Math.abs(r.y + r.h - ball.y);
                const m = Math.min(left, right, top, bottom);
                if(m === left){ ball.x = r.x - COLL_R; reflect(-1,0); }
                else if(m === right){ ball.x = r.x + r.w + COLL_R; reflect(1,0); }
                else if(m === top){ ball.y = r.y - COLL_R; reflect(0,-1); }
                else { ball.y = r.y + r.h + COLL_R; reflect(0,1); }
            }
        }

	        function collideCircle(c){
	            if(!c) return;
	            const dx = ball.x - c.x, dy = ball.y - c.y;
	            const d = Math.hypot(dx, dy);
	            const rr = COLL_R + c.r;
	            if(d > 0 && d < rr){
	                if(c.kind === 'unicorn'){
	                    if(startChomp(c)) return;
	                }
	                const nx = dx / d, ny = dy / d;
	                const push = (rr - d) + 0.2;
	                ball.x += nx * push;
	                ball.y += ny * push;
	                reflect(nx, ny, (c.kind === 'unicorn') ? 0.95 : 0.90);
	            }
	        }

	        function collideSeg(s){
	            
	            const x1=s.x1, y1=s.y1, x2=s.x2, y2=s.y2;
	            const vx = x2-x1, vy = y2-y1;
	            const l2 = vx*vx + vy*vy;
	            if(l2 <= 0.0001) return;
	            
	            let t = ((ball.x-x1)*vx + (ball.y-y1)*vy) / l2;
	            t = clamp(t, 0, 1);
	            const px = x1 + vx*t, py = y1 + vy*t;
	            const dx = ball.x - px, dy = ball.y - py;
	            const d = Math.hypot(dx, dy);
	            const rr = COLL_R + (s.t||18)/2;
	            if(d > 0 && d < rr){
	                const nx = dx / d, ny = dy / d;
	                const push = (rr - d) + 0.25;
	                ball.x += nx * push;
	                ball.y += ny * push;
	                reflect(nx, ny, 0.92);
	            }
	        }

        function collideRotor(r){
            const sin = Math.sin(r.ang), cos = Math.cos(r.ang);
            const dx = ball.x - r.x, dy = ball.y - r.y;
            const lx =  cos*dx + sin*dy;
            const ly = -sin*dx + cos*dy;

            const hx = r.L/2, hy = r.T/2;
            const cx = clamp(lx, -hx, hx);
            const cy = clamp(ly, -hy, hy);
            let ex = lx - cx, ey = ly - cy;
            const dist = Math.hypot(ex, ey);

            if(dist > 0 && dist < COLL_R){
                const nxL = ex / dist, nyL = ey / dist;

                const push = (COLL_R - dist) + 0.2;
                const nlx = lx + nxL * push;
                const nly = ly + nyL * push;

                ball.x = r.x + cos*nlx - sin*nly;
                ball.y = r.y + sin*nlx + cos*nly;

                const nx = cos*nxL - sin*nyL;
                const ny = sin*nxL + cos*nyL;

                reflect(nx, ny, 0.88);

                const rx = ball.x - r.x, ry = ball.y - r.y;
                const omega = r.speed; 
                const pvx = -omega * ry;
                const pvy =  omega * rx;
                ball.vx += pvx * 0.15;
                ball.vy += pvy * 0.15;
            }
        }

        function reflect(nx, ny, rest=REST){
            const vdot = ball.vx*nx + ball.vy*ny;
            if(vdot < 0){
                ball.vx = (ball.vx - 2*vdot*nx) * rest;
                ball.vy = (ball.vy - 2*vdot*ny) * rest;
            }
        }

        
        function setDifficulty(v){
            const d = (v === 'easy' || v === 'medium' || v === 'hard') ? v : 'easy';
            previewDifficulty = d;
            storeDifficulty(d);
            updateDiffUI();
        }

        function previewReflect(tb, nx, ny, rest=REST){
            const vdot = tb.vx*nx + tb.vy*ny;
            if(vdot < 0){
                tb.vx = (tb.vx - 2*vdot*nx) * rest;
                tb.vy = (tb.vy - 2*vdot*ny) * rest;
            }
        }
        function previewWallBounds(tb){
            const minX = PAD + BALL_R, maxX = W - PAD - BALL_R;
            const minY = PAD + BALL_R, maxY = H - PAD - BALL_R;

            if(tb.x < minX){ tb.x = minX; tb.vx = Math.abs(tb.vx) * REST; }
            if(tb.x > maxX){ tb.x = maxX; tb.vx = -Math.abs(tb.vx) * REST; }
            if(tb.y < minY){ tb.y = minY; tb.vy = Math.abs(tb.vy) * REST; }
            if(tb.y > maxY){ tb.y = maxY; tb.vy = -Math.abs(tb.vy) * REST; }
        }
        function previewCollideRect(tb, r){
            const cx = clamp(tb.x, r.x, r.x + r.w);
            const cy = clamp(tb.y, r.y, r.y + r.h);
            let dx = tb.x - cx;
            let dy = tb.y - cy;
            const dist = Math.hypot(dx, dy);

            if(dist > 0 && dist < COLL_R){
                const nx = dx / dist;
                const ny = dy / dist;
                const push = (COLL_R - dist) + 0.2;
                tb.x += nx * push;
                tb.y += ny * push;
                previewReflect(tb, nx, ny);
            } else if(dist === 0){
                const left = Math.abs(tb.x - r.x);
                const right = Math.abs(r.x + r.w - tb.x);
                const top = Math.abs(tb.y - r.y);
                const bottom = Math.abs(r.y + r.h - tb.y);
                const m = Math.min(left, right, top, bottom);
                if(m === left){ tb.x = r.x - COLL_R; previewReflect(tb, -1, 0); }
                else if(m === right){ tb.x = r.x + r.w + COLL_R; previewReflect(tb, 1, 0); }
                else if(m === top){ tb.y = r.y - COLL_R; previewReflect(tb, 0, -1); }
                else { tb.y = r.y + r.h + COLL_R; previewReflect(tb, 0, 1); }
            }
        }
        function previewCollideCircle(tb, c){
            if(!c) return;
            const dx = tb.x - c.x, dy = tb.y - c.y;
            const d = Math.hypot(dx, dy);
            const rr = COLL_R + c.r;
            if(d > 0 && d < rr){
                const nx = dx / d, ny = dy / d;
                const push = (rr - d) + 0.2;
                tb.x += nx * push;
                tb.y += ny * push;
                previewReflect(tb, nx, ny, (c.kind === 'unicorn') ? 0.95 : 0.90);
            } else if(d === 0){
                tb.x += 0.1;
            }
        }
        function previewCollideSeg(tb, s){
            const x1=s.x1, y1=s.y1, x2=s.x2, y2=s.y2;
            const vx = x2-x1, vy = y2-y1;
            const l2 = vx*vx + vy*vy;
            if(l2 <= 0.0001) return;

            let t = ((tb.x-x1)*vx + (tb.y-y1)*vy) / l2;
            t = clamp(t, 0, 1);
            const px = x1 + vx*t, py = y1 + vy*t;
            const dx = tb.x - px, dy = tb.y - py;
            const d = Math.hypot(dx, dy);
            const rr = COLL_R + (s.t||18)/2;

            if(d > 0 && d < rr){
                const nx = dx / d, ny = dy / d;
                const push = (rr - d) + 0.25;
                tb.x += nx * push;
                tb.y += ny * push;
                previewReflect(tb, nx, ny, 0.9);
            }
        }
        function previewCollideRotor(tb, r){
            const sin = Math.sin(r.ang), cos = Math.cos(r.ang);
            const dx = tb.x - r.x, dy = tb.y - r.y;
            const lx =  cos*dx + sin*dy;
            const ly = -sin*dx + cos*dy;

            const hx = r.L/2, hy = r.T/2;
            const cx = clamp(lx, -hx, hx);
            const cy = clamp(ly, -hy, hy);
            let ex = lx - cx, ey = ly - cy;
            const dist = Math.hypot(ex, ey);

            if(dist > 0 && dist < COLL_R){
                const nxL = ex / dist, nyL = ey / dist;
                const push = (COLL_R - dist) + 0.2;
                const nlx = lx + nxL * push;
                const nly = ly + nyL * push;

                tb.x = r.x + cos*nlx - sin*nly;
                tb.y = r.y + sin*nlx + cos*nly;

                const nx = cos*nxL - sin*nyL;
                const ny = sin*nxL + cos*nyL;

                previewReflect(tb, nx, ny, 0.88);

                const rx = tb.x - r.x, ry = tb.y - r.y;
                const omega = r.speed;
                const pvx = -omega * ry;
                const pvy =  omega * rx;
                tb.vx += pvx * 0.15;
                tb.vy += pvy * 0.15;
            }
        }

        function computePreviewPath(nx, ny, pwr){
            if(!cur) return null;

            const speed = 150 + 1710 * pwr;
            const tb = { x: ball.x, y: ball.y, vx: nx * speed, vy: ny * speed };

            const simRotors = (cur.rotors || []).map(r => ({
                x: r.x, y: r.y, L: r.L, T: r.T, speed: r.speed, ang: r.ang
            }));

            const pts = [{x: tb.x, y: tb.y}];
            const dt = 1/120;
            let steps = 0;

            while(steps < 9000){
                for(const r of simRotors) r.ang += r.speed * dt;

                tb.x += tb.vx * dt;
                tb.y += tb.vy * dt;

                let decay = BASE_DECAY;
                if(cur.sands && cur.sands.some(z => pointInRect(tb.x, tb.y, z))) decay = SAND_DECAY;
                const f = Math.pow(decay, dt * 60);
                tb.vx *= f;
                tb.vy *= f;

                if(Math.hypot(tb.vx, tb.vy) < 10){
                    tb.vx = 0; tb.vy = 0;
                }

                previewWallBounds(tb);

                if(cur.blocks) for(const b of cur.blocks) previewCollideRect(tb, b);
                if(cur.bumpers) for(const c of cur.bumpers){ if(c && c.type==='seg') previewCollideSeg(tb, c); else previewCollideCircle(tb, c); }
                for(const r of simRotors) previewCollideRotor(tb, r);

                if(cur.waters && cur.waters.some(z => pointInRect(tb.x, tb.y, z))){
                    pts.push({x: tb.x, y: tb.y});
                    break;
                }

                if(steps % 3 === 0) pts.push({x: tb.x, y: tb.y});
                if(tb.vx === 0 && tb.vy === 0){
                    pts.push({x: tb.x, y: tb.y});
                    break;
                }
                steps++;
            }

            return pts;
        }

function draw(){
            if(!cur) return false;

            ctx.setTransform(1,0,0,1,0,0);
            ctx.clearRect(0,0,canvas.width, canvas.height);
            ctx.setTransform(dpr*scalePx, 0, 0, dpr*scalePx, dpr*offPxX, dpr*offPxY);

            ctx.fillStyle = '#0b160a';
            ctx.fillRect(0,0,W,H);

            ctx.fillStyle = '#1e5a1a';
            roundRect(PAD, PAD, W-PAD*2, H-PAD*2, 22);
            ctx.fill();

            ctx.globalAlpha = 0.08;
            ctx.fillStyle = '#fff';
            for(let x=PAD; x<W-PAD; x+=70){
                ctx.fillRect(x, PAD, 28, H-PAD*2);
            }
            ctx.globalAlpha = 1;

            if(cur.sands){
                for(const s of cur.sands){
                    ctx.fillStyle = 'rgba(255, 216, 128, 0.9)';
                    roundRect(s.x, s.y, s.w, s.h, 18);
                    ctx.fill();
                    ctx.strokeStyle = 'rgba(0,0,0,0.25)';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                }
            }

            if(cur.waters){
                for(const w of cur.waters){
                    ctx.fillStyle = 'rgba(0, 229, 255, 0.28)';
                    roundRect(w.x, w.y, w.w, w.h, 18);
                    ctx.fill();
                    ctx.strokeStyle = 'rgba(0, 229, 255, 0.35)';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            }

            ctx.strokeStyle = 'rgba(0,0,0,0.65)';
            ctx.lineWidth = 18;
            roundRect(PAD, PAD, W-PAD*2, H-PAD*2, 22);
            ctx.stroke();

            ctx.strokeStyle = 'rgba(255,255,255,0.12)';
            ctx.lineWidth = 2;
            roundRect(PAD+8, PAD+8, W-PAD*2-16, H-PAD*2-16, 18);
            ctx.stroke();

            if(cur.blocks){
                for(const b of cur.blocks){
                    ctx.fillStyle = '#3b2a12';
                    ctx.fillRect(b.x, b.y, b.w, b.h);
                    ctx.strokeStyle = 'rgba(255,255,255,0.12)';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(b.x, b.y, b.w, b.h);
                }
            }

            if(cur.bumpers){
                for(const c of cur.bumpers){
                    if(c && c.type==='seg'){
                        ctx.save();
                        ctx.strokeStyle = 'rgba(255,255,255,0.18)';
                        ctx.lineWidth = (c.t||18);
                        ctx.lineCap = 'round';
                        
                        ctx.globalAlpha = 0.25;
                        ctx.beginPath();
                        ctx.moveTo(c.x1+6, c.y1+6);
                        ctx.lineTo(c.x2+6, c.y2+6);
                        ctx.stroke();
                        ctx.globalAlpha = 1;

                        ctx.strokeStyle = '#ffd700';
                        ctx.beginPath();
                        ctx.moveTo(c.x1, c.y1);
                        ctx.lineTo(c.x2, c.y2);
                        ctx.stroke();
                        ctx.restore();
                        continue;
                    }

	                    
                    ctx.beginPath();
                    ctx.fillStyle = '#111';
                    ctx.arc(c.x, c.y, c.r+3, 0, Math.PI*2);
                    ctx.fill();

                    ctx.beginPath();
	                    ctx.fillStyle = (c.kind==='tree') ? '#33cc66' : (c.kind==='unicorn' ? '#caa0ff' : '#ffd700');
                    ctx.arc(c.x, c.y, c.r, 0, Math.PI*2);
                    ctx.fill();

	                    if(c.kind === 'unicorn'){
	                        
	                        ctx.save();
	                        ctx.translate(c.x, c.y);
	                        ctx.rotate(-0.35);
	                        ctx.fillStyle = 'rgba(255,255,255,0.92)';
	                        ctx.beginPath();
	                        ctx.moveTo(0, -c.r + 2);
	                        ctx.lineTo(8, -c.r - 12);
	                        ctx.lineTo(16, -c.r + 2);
	                        ctx.closePath();
	                        ctx.fill();
	                        ctx.restore();

	                        ctx.fillStyle = 'rgba(0,0,0,0.65)';
	                        ctx.beginPath();
	                        ctx.arc(c.x + c.r*0.18, c.y - c.r*0.12, 2.4, 0, Math.PI*2);
	                        ctx.fill();
	                    }

                    ctx.strokeStyle = 'rgba(255,255,255,0.18)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(c.x, c.y, c.r, 0, Math.PI*2);
                    ctx.stroke();
                }
            }

            
            if(cur.rotors){
                for(const r of cur.rotors){
                    ctx.save();
                    ctx.translate(r.x, r.y);
                    ctx.rotate(r.ang);

                    
                    ctx.globalAlpha = 0.12;
                    ctx.beginPath();
                    ctx.strokeStyle = 'rgba(255,255,255,0.55)';
                    ctx.lineWidth = 2;
                    ctx.arc(0,0, (r.L*0.55), 0, Math.PI*2);
                    ctx.stroke();

                    ctx.globalAlpha = 1;
                    ctx.fillStyle = 'rgba(255,82,82,0.88)';
                    ctx.strokeStyle = 'rgba(0,0,0,0.35)';
                    ctx.lineWidth = 2;
                    roundRect(-r.L/2, -r.T/2, r.L, r.T, Math.min(10, r.T/2));
                    ctx.fill();
                    ctx.stroke();

                    
                    ctx.fillStyle = '#111';
                    ctx.beginPath();
                    ctx.arc(0,0, 12, 0, Math.PI*2);
                    ctx.fill();
                    ctx.strokeStyle = 'rgba(255,255,255,0.20)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0,0, 12, 0, Math.PI*2);
                    ctx.stroke();

                    ctx.restore();
                }
            }

const cup = cur.cup;
            ctx.beginPath();
            ctx.fillStyle = '#000';
            ctx.arc(cup.x, cup.y, cup.r+6, 0, Math.PI*2);
            ctx.fill();
            ctx.beginPath();
            ctx.fillStyle = '#222';
            ctx.arc(cup.x, cup.y, cup.r+2, 0, Math.PI*2);
            ctx.fill();
            ctx.beginPath();
            ctx.fillStyle = '#000';
            ctx.arc(cup.x, cup.y, cup.r, 0, Math.PI*2);
            ctx.fill();

            if(sink.mode !== 'none'){
                ctx.save();
                ctx.translate(cup.x, cup.y);
                const pulse = 0.5 + 0.5*Math.sin(sink.t * 18);
                const baseAng = sink.ang || 0;

                ctx.globalAlpha = 0.20 + 0.22*pulse;
                for(let i=0;i<3;i++){
                    ctx.beginPath();
                    ctx.strokeStyle = 'rgba(0,229,255,0.85)';
                    ctx.lineWidth = 5 - i;
                    const rr = cup.r + 10 + i*6;
                    ctx.arc(0,0, rr, baseAng + i*0.85, baseAng + i*0.85 + Math.PI*1.25);
                    ctx.stroke();
                }
                ctx.globalAlpha = 1;
                ctx.restore();
            }

            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(cup.x, cup.y - cup.r - 6);
            ctx.lineTo(cup.x, cup.y - cup.r - 90);
            ctx.stroke();
            ctx.fillStyle = '#ff5252';
            ctx.beginPath();
            ctx.moveTo(cup.x, cup.y - cup.r - 90);
            ctx.lineTo(cup.x + 46, cup.y - cup.r - 74);
            ctx.lineTo(cup.x, cup.y - cup.r - 58);
            ctx.closePath();
            ctx.fill();

            
            if(!isBallMoving() && sink.mode === 'none' && menuOv.style.display === 'none' && holeOv.style.display === 'none' && roundOv.style.display === 'none'){
                const nx = (aim.dx || 1);
                const ny = (aim.dy || 0);
                const pwr = clamp(aim.power || 0, 0, 1);

                const L = 115 + 135*pwr;
                ctx.strokeStyle = 'rgba(0,229,255,0.9)';
                ctx.lineWidth = 5;
                ctx.beginPath();
                ctx.moveTo(ball.x, ball.y);
                ctx.lineTo(ball.x + nx*L, ball.y + ny*L);
                ctx.stroke();

                ctx.fillStyle = 'rgba(0,229,255,0.9)';
                ctx.beginPath();
                ctx.arc(ball.x + nx*L, ball.y + ny*L, 7, 0, Math.PI*2);
                ctx.fill();

                
                const showDots = (previewDifficulty !== 'hard');
                if(showDots){
                    const rotTick = (cur && cur.rotors && cur.rotors.length) ? Math.floor(gameTime * 10) : 0;
                    const key = `${holeIndex}|${ball.x.toFixed(1)}|${ball.y.toFixed(1)}|${nx.toFixed(3)}|${ny.toFixed(3)}|${pwr.toFixed(3)}|${previewDifficulty}|${rotTick}`;
                    if(key !== previewKey){
                        previewPts = computePreviewPath(nx, ny, pwr);
                        previewKey = key;
                    }

                    if(previewPts && previewPts.length > 1){
                        let pts = previewPts;

                        if(previewDifficulty === 'medium'){
                            let total = 0;
                            for(let i=1;i<pts.length;i++){
                                total += Math.hypot(pts[i].x-pts[i-1].x, pts[i].y-pts[i-1].y);
                            }
                            const maxLen = Math.min(total * 0.45, 720);
                            const out = [pts[0]];
                            let acc = 0;
                            for(let i=1;i<pts.length;i++){
                                const seg = Math.hypot(pts[i].x-pts[i-1].x, pts[i].y-pts[i-1].y);
                                if(acc + seg > maxLen) break;
                                acc += seg;
                                out.push(pts[i]);
                            }
                            pts = out;
                        }

                        if(pts.length > 1){
                            ctx.save();
                            ctx.setLineDash([7, 9]);
                            ctx.lineWidth = 3;
                            ctx.strokeStyle = 'rgba(255,255,255,0.55)';
                            ctx.beginPath();
                            ctx.moveTo(pts[0].x, pts[0].y);
                            for(let i=1;i<pts.length;i++) ctx.lineTo(pts[i].x, pts[i].y);
                            ctx.stroke();

                            const last = pts[pts.length - 1];
                            ctx.setLineDash([]);
                            ctx.fillStyle = 'rgba(255,255,255,0.7)';
                            ctx.beginPath();
                            ctx.arc(last.x, last.y, 5, 0, Math.PI*2);
                            ctx.fill();
                            ctx.restore();
                        }
                    }
                }
            }

            if(ball.r > 0){
                ctx.beginPath();
                ctx.fillStyle = '#fff';
                ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI*2);
                ctx.fill();

                ctx.beginPath();
                ctx.fillStyle = 'rgba(0,0,0,0.12)';
                ctx.arc(ball.x - ball.r*0.25, ball.y - ball.r*0.25, ball.r*0.55, 0, Math.PI*2);
                ctx.fill();

                ctx.beginPath();
                ctx.strokeStyle = 'rgba(0,0,0,0.35)';
                ctx.lineWidth = 2;
                ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI*2);
                ctx.stroke();
            }

        }


        function roundRect(x,y,w,h,r){
            const rr = Math.min(r, w/2, h/2);
            ctx.beginPath();
            ctx.moveTo(x+rr, y);
            ctx.arcTo(x+w, y, x+w, y+h, rr);
            ctx.arcTo(x+w, y+h, x, y+h, rr);
            ctx.arcTo(x, y+h, x, y, rr);
            ctx.arcTo(x, y, x+w, y, rr);
            ctx.closePath();
        }

        function toWorld(clientX, clientY){
            const rect = canvas.getBoundingClientRect();
            const sx = (clientX - rect.left);
            const sy = (clientY - rect.top);
            const wx = (sx - offPxX) / (scalePx || 1);
            const wy = (sy - offPxY) / (scalePx || 1);
            return { x: wx, y: wy };
        }

        function resize(){
            if(!wrap) return;
            dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
            const w = wrap.clientWidth;
            const h = wrap.clientHeight;

            canvas.width = Math.floor(w * dpr);
            canvas.height = Math.floor(h * dpr);

            scalePx = Math.min(w / W, h / H);
            offPxX = (w - W * scalePx) / 2;
            offPxY = (h - H * scalePx) / 2;

            updateStickUI();

            draw();
        }

        function startOrContinue(){
            menuOv.style.display = 'none';
            holeOv.style.display = 'none';
            roundOv.style.display = 'none';

            if(!started){
                restartRound();
                return;
            }

            active = true;
            resize();
            startLoop();
        }

        function openMenu(){
            menuOv.style.display = 'flex';
            holeOv.style.display = 'none';
            roundOv.style.display = 'none';
            stickDragging = false;
            updatePower(0);
            active = true;
            resize();
            draw();
        }

        function restartHole(){
            if(!started) return restartRound();
            totalStrokes -= strokesThis;
            strokesThis = 0;
            holeStrokes[holeIndex] = 0;
            updateUI();
            ball.x = cur.start.x; ball.y = cur.start.y;
            ball.vx = 0; ball.vy = 0;
            ball.r = BALL_R;
            sink.mode = 'none'; sink.t = 0;
            feedbackShown = false;
            updatePower(0);
            holeOv.style.display = 'none';
            roundOv.style.display = 'none';
            menuOv.style.display = 'none';
            showMsg("RESTART!", 700);
        }

        function restartRound(){
            started = true;
            totalStrokes = 0;
            holeStrokes = Array(18).fill(0);

            buildHoles();
            holeOrder = shuffle(Array.from({length:18}, (_,i)=>i));
            loadHole(0);

            menuOv.style.display = 'none';
            holeOv.style.display = 'none';
            roundOv.style.display = 'none';

            active = true;
            resize();
            startLoop();
            showMsg("HOLE 1", 800);
        }

        function onHoleComplete(){
            const par = cur.par || 3;
            const diff = strokesThis - par;
            const diffText = diff === 0 ? "E" : (diff > 0 ? "+" + diff : String(diff));
            holeSub.textContent = `Strokes: ${strokesThis} (Par ${par}, ${diffText})`;

            if(holeIndex >= 17){
                const tPar = totalPar();
                const tDiff = totalStrokes - tPar;
                const tDiffText = tDiff === 0 ? "E" : (tDiff > 0 ? "+" + tDiff : String(tDiff));
                roundSub.textContent = `Total: ${totalStrokes} (Par ${tPar}, ${tDiffText})`;
                
                if(totalStrokes > 0){
                    const prev = bestTotal;
                    if(!prev || totalStrokes < prev){
                        bestTotal = totalStrokes;
                        try{ if(window.ArcadeStore) ArcadeStore.setNum('minigolf_best_total', bestTotal); }catch(e){}
                        if(bestTotalEl) bestTotalEl.textContent = String(bestTotal);
                    }
                    if(bestTotal){
                        roundSub.textContent += `  Best: ${bestTotal}`;
                    }
                }
                roundOv.style.display = 'flex';
                holeOv.style.display = 'none';
            } else {
                holeOv.style.display = 'flex';
            }
        }

        function nextHole(){
            if(!started) return restartRound();
            holeOv.style.display = 'none';
            roundOv.style.display = 'none';
            const next = holeIndex + 1;
            if(next >= 18){
                roundOv.style.display = 'flex';
                return;
            }
            loadHole(next);
            active = true;
            resize();
            startLoop();
            showMsg("HOLE " + (holeIndex+1), 800);
        }

        function quit(){
            active = false;
            loopGen++;
            stickDragging = false;
            sink.mode = 'none'; sink.t = 0;
            ball.vx = 0; ball.vy = 0;
            if(raf) cancelAnimationFrame(raf);
            raf = null;
            aim.on = false;
            updatePower(0);
        }

        buildHoles();
        initDom();
        menuOv.style.display = 'flex';
        holeOv.style.display = 'none';
        roundOv.style.display = 'none';
        resize();
        draw();

        return { openMenu, startOrContinue, shoot, restartHole, nextHole, restartRound, resize, quit, setDifficulty };
    })();

window.addEventListener('resize', () => {
        try{ if(window.MiniGolf && typeof MiniGolf.resize === 'function') MiniGolf.resize(); }catch(e){}
    });

try{ window.MiniGolf = MiniGolf; }catch(e){}
try{ window.FeedbackSys = FeedbackSys; }catch(e){}

function goToMenu() {
    try{ ArcadeSettings.closeModal(); }catch(e){}
    try{
        if(currentGameId === 'minigolf' && window.MiniGolf && typeof MiniGolf.quit === 'function') {
            MiniGolf.quit();
        }
    }catch(e){}
    window.location.href = 'index.html';
}

try{
    currentGameId = 'minigolf';
    const view = document.getElementById('g-minigolf');
    if(view) view.classList.add('active');
}catch(e){}

try{
    MiniGolf.openMenu(); setTimeout(() => MiniGolf.resize(), 50);
}catch(e){}

(function(){
  function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }
  function installDrag(el, key){
    if(!el) return;
    const storeKey = 'arcade_drag_' + key;
    let dragging = false;
    let moved = false;
    let startX=0, startY=0, startL=0, startT=0;

    
    try{
      const raw = localStorage.getItem(storeKey);
      if(raw){
        const p = JSON.parse(raw);
        if(p && typeof p.left==='number' && typeof p.top==='number'){
          el.style.left = p.left + 'px';
          el.style.top  = p.top  + 'px';
          el.style.right = 'auto';
          el.style.bottom = 'auto';
          el.classList.add('drag-restored');
        }
      }
    }catch(e){}

    
    const cs = getComputedStyle(el);
    if(cs.position !== 'fixed') el.style.position = 'fixed';

    el.addEventListener('pointerdown', (e)=>{
      if(e.button !== undefined && e.button !== 0) return;
      dragging = true; moved = false;
      el.setPointerCapture?.(e.pointerId);
      const r = el.getBoundingClientRect();
      startX = e.clientX; startY = e.clientY;
      startL = r.left; startT = r.top;
      el.classList.add('dragging');
    });

    window.addEventListener('pointermove', (e)=>{
      if(!dragging) return;
      const dx = e.clientX - startX;
      const dy = e.clientY - startY;
      if(!moved && (Math.abs(dx) + Math.abs(dy)) > 8) moved = true;
      if(!moved) return;
      e.preventDefault();
      const w = el.offsetWidth, h = el.offsetHeight;
      const maxL = window.innerWidth - w - 6;
      const maxT = window.innerHeight - h - 6;
      const L = clamp(startL + dx, 6, maxL);
      const T = clamp(startT + dy, 6, maxT);
      el.style.left = L + 'px';
      el.style.top  = T + 'px';
      el.style.right = 'auto';
      el.style.bottom = 'auto';
    }, {passive:false});

    window.addEventListener('pointerup', (e)=>{
      if(!dragging) return;
      dragging = false;
      el.classList.remove('dragging');
      if(moved){
        
        try{
          const r = el.getBoundingClientRect();
          localStorage.setItem(storeKey, JSON.stringify({left:r.left, top:r.top}));
        }catch(e){}
        
        const swallow = (ev)=>{ ev.preventDefault(); ev.stopPropagation(); };
        el.addEventListener('click', swallow, {once:true, capture:true});
      }
    });
  }

  
  try{ installDrag(document.querySelector('.back-btn'), 'menu'); }catch(e){}
  try{ installDrag(document.getElementById('global-settings-btn'), 'settings'); }catch(e){}
})();

    
    (function(){
        function installDrag(el, key){
            if(!el) return;
            const storeKey = 'arcade_drag_' + key;
            let dragging = false;
            let pointerId = null;
            let sx=0, sy=0, startLeft=0, startTop=0;
            let moved = false;

            
            try{
                const raw = localStorage.getItem(storeKey);
                if(raw){
                    const p = JSON.parse(raw);
                    if(p && Number.isFinite(p.left) && Number.isFinite(p.top)){
                        el.style.left = p.left + 'px';
                        el.style.top  = p.top + 'px';
                        el.style.right = 'auto';
                    }
                }
            }catch(e){}

            function clamp(v, lo, hi){ return Math.max(lo, Math.min(hi, v)); }

            el.addEventListener('pointerdown', (e) => {
                
                if(pointerId !== null) return;
                pointerId = e.pointerId;
                try{ el.setPointerCapture(pointerId); }catch(_e){}

                const r = el.getBoundingClientRect();
                sx = e.clientX; sy = e.clientY;
                startLeft = r.left; startTop = r.top;
                dragging = true;
                moved = false;
                el.classList.add('dragging');
            });

            window.addEventListener('pointermove', (e) => {
                if(!dragging || e.pointerId !== pointerId) return;
                const dx = e.clientX - sx;
                const dy = e.clientY - sy;
                if(!moved && (Math.abs(dx) + Math.abs(dy) > 8)) moved = true;
                if(!moved) return;

                const vw = window.innerWidth;
                const vh = window.innerHeight;
                const r = el.getBoundingClientRect();
                const w = r.width;
                const h = r.height;

                let left = startLeft + dx;
                let top  = startTop + dy;
                left = clamp(left, 6, vw - w - 6);
                top  = clamp(top, 6, vh - h - 6);

                el.style.left = left + 'px';
                el.style.top  = top + 'px';
                el.style.right = 'auto';
                el.style.bottom = 'auto';

                try{
                    localStorage.setItem(storeKey, JSON.stringify({left, top}));
                }catch(_e){}

                e.preventDefault();
            }, { passive:false });

            function end(e){
                if(e && pointerId !== null && e.pointerId !== pointerId) return;
                if(!dragging) return;
                dragging = false;
                el.classList.remove('dragging');
                try{ if(pointerId !== null) el.releasePointerCapture(pointerId); }catch(_e){}
                pointerId = null;
            }

            window.addEventListener('pointerup', end);
            window.addEventListener('pointercancel', end);

            
            el.addEventListener('click', (e) => {
                if(moved){
                    e.preventDefault();
                    e.stopPropagation();
                    moved = false;
                }
            }, true);
        }

        installDrag(document.querySelector('.back-btn'), 'menu');
        installDrag(document.getElementById('global-settings-btn'), 'settings');
    })();

(function(){
  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
  function installDrag(el, key){
    if(!el || el.__dragInstalled) return;
    el.__dragInstalled = true;
    el.style.touchAction = 'none';
    el.style.userSelect = 'none';
    el.style.webkitUserSelect = 'none';

    const storeKey = 'arcade_btnpos_' + key;
    try{
      const raw = localStorage.getItem(storeKey);
      if(raw){
        const p = JSON.parse(raw);
        if(p && Number.isFinite(p.x) && Number.isFinite(p.y)){
          el.style.left = p.x + 'px';
          el.style.top = p.y + 'px';
          el.style.right = 'auto';
          el.style.bottom = 'auto';
        }
      }
    }catch(e){}

    let dragging = false;
    let downX=0, downY=0, startLeft=0, startTop=0;

    function getLeft(){
      const r = el.getBoundingClientRect();
      return r.left;
    }
    function getTop(){
      const r = el.getBoundingClientRect();
      return r.top;
    }

    el.addEventListener('pointerdown', (ev)=>{
      if(ev.button != null && ev.button !== 0) return;
      dragging = false;
      downX = ev.clientX; downY = ev.clientY;
      startLeft = getLeft(); startTop = getTop();
      el.setPointerCapture(ev.pointerId);
    });

    el.addEventListener('pointermove', (ev)=>{
      if(!el.hasPointerCapture(ev.pointerId)) return;
      const dx = ev.clientX - downX;
      const dy = ev.clientY - downY;
      if(!dragging){
        if(Math.hypot(dx,dy) < 6) return;
        dragging = true;
        el.classList.add('dragging');
        
        el.style.left = startLeft + 'px';
        el.style.top = startTop + 'px';
        el.style.right = 'auto';
        el.style.bottom = 'auto';
      }
      ev.preventDefault();
      const vw = window.innerWidth;
      const vh = window.innerHeight;
      const rect = el.getBoundingClientRect();
      const newLeft = clamp(startLeft + dx, 6, vw - rect.width - 6);
      const newTop  = clamp(startTop + dy, 6, vh - rect.height - 6);
      el.style.left = newLeft + 'px';
      el.style.top  = newTop + 'px';
    }, { passive:false });

    function finish(ev){
      if(!el.hasPointerCapture(ev.pointerId)) return;
      el.releasePointerCapture(ev.pointerId);
      if(dragging){
        ev.preventDefault();
        ev.stopPropagation();
        el.classList.remove('dragging');
        try{
          const r = el.getBoundingClientRect();
          localStorage.setItem(storeKey, JSON.stringify({x: Math.round(r.left), y: Math.round(r.top)}));
        }catch(e){}
      }
      dragging = false;
    }
    el.addEventListener('pointerup', finish);
    el.addEventListener('pointercancel', finish);

    
    el.addEventListener('click', (ev)=>{
      if(el.classList.contains('dragging')){ ev.preventDefault(); ev.stopPropagation(); }
    }, true);
  }

  try{ installDrag(document.querySelector('.back-btn'), 'menu'); }catch(e){}
  try{ installDrag(document.getElementById('global-settings-btn'), 'settings'); }catch(e){}
})();

</script>
</body>
</html>
